                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 3.4.0 #8981 (Apr  5 2014) (MINGW32)
                                      4 ; This file was generated Fri Apr 10 13:22:20 2015
                                      5 ;--------------------------------------------------------
                                      6 	.module Lab_4
                                      7 	.optsdcc -mmcs51 --model-small
                                      8 	
                                      9 ;--------------------------------------------------------
                                     10 ; Public variables in this module
                                     11 ;--------------------------------------------------------
                                     12 	.globl _steering_gain
                                     13 	.globl _main
                                     14 	.globl _read_keypad
                                     15 	.globl _strlen
                                     16 	.globl _vsprintf
                                     17 	.globl _printf
                                     18 	.globl _Sys_Init
                                     19 	.globl _UART0_Init
                                     20 	.globl _SYSCLK_Init
                                     21 	.globl _RANGER_SWITCH
                                     22 	.globl _COMPASS_SWITCH
                                     23 	.globl _BUS_SCL
                                     24 	.globl _BUS_TOE
                                     25 	.globl _BUS_FTE
                                     26 	.globl _BUS_AA
                                     27 	.globl _BUS_INT
                                     28 	.globl _BUS_STOP
                                     29 	.globl _BUS_START
                                     30 	.globl _BUS_EN
                                     31 	.globl _BUS_BUSY
                                     32 	.globl _SPIF
                                     33 	.globl _WCOL
                                     34 	.globl _MODF
                                     35 	.globl _RXOVRN
                                     36 	.globl _TXBSY
                                     37 	.globl _SLVSEL
                                     38 	.globl _MSTEN
                                     39 	.globl _SPIEN
                                     40 	.globl _AD0EN
                                     41 	.globl _ADCEN
                                     42 	.globl _AD0TM
                                     43 	.globl _ADCTM
                                     44 	.globl _AD0INT
                                     45 	.globl _ADCINT
                                     46 	.globl _AD0BUSY
                                     47 	.globl _ADBUSY
                                     48 	.globl _AD0CM1
                                     49 	.globl _ADSTM1
                                     50 	.globl _AD0CM0
                                     51 	.globl _ADSTM0
                                     52 	.globl _AD0WINT
                                     53 	.globl _ADWINT
                                     54 	.globl _AD0LJST
                                     55 	.globl _ADLJST
                                     56 	.globl _CF
                                     57 	.globl _CR
                                     58 	.globl _CCF4
                                     59 	.globl _CCF3
                                     60 	.globl _CCF2
                                     61 	.globl _CCF1
                                     62 	.globl _CCF0
                                     63 	.globl _CY
                                     64 	.globl _AC
                                     65 	.globl _F0
                                     66 	.globl _RS1
                                     67 	.globl _RS0
                                     68 	.globl _OV
                                     69 	.globl _F1
                                     70 	.globl _P
                                     71 	.globl _TF2
                                     72 	.globl _EXF2
                                     73 	.globl _RCLK
                                     74 	.globl _TCLK
                                     75 	.globl _EXEN2
                                     76 	.globl _TR2
                                     77 	.globl _CT2
                                     78 	.globl _CPRL2
                                     79 	.globl _BUSY
                                     80 	.globl _ENSMB
                                     81 	.globl _STA
                                     82 	.globl _STO
                                     83 	.globl _SI
                                     84 	.globl _AA
                                     85 	.globl _SMBFTE
                                     86 	.globl _SMBTOE
                                     87 	.globl _PT2
                                     88 	.globl _PS
                                     89 	.globl _PS0
                                     90 	.globl _PT1
                                     91 	.globl _PX1
                                     92 	.globl _PT0
                                     93 	.globl _PX0
                                     94 	.globl _P3_7
                                     95 	.globl _P3_6
                                     96 	.globl _P3_5
                                     97 	.globl _P3_4
                                     98 	.globl _P3_3
                                     99 	.globl _P3_2
                                    100 	.globl _P3_1
                                    101 	.globl _P3_0
                                    102 	.globl _EA
                                    103 	.globl _ET2
                                    104 	.globl _ES
                                    105 	.globl _ES0
                                    106 	.globl _ET1
                                    107 	.globl _EX1
                                    108 	.globl _ET0
                                    109 	.globl _EX0
                                    110 	.globl _P2_7
                                    111 	.globl _P2_6
                                    112 	.globl _P2_5
                                    113 	.globl _P2_4
                                    114 	.globl _P2_3
                                    115 	.globl _P2_2
                                    116 	.globl _P2_1
                                    117 	.globl _P2_0
                                    118 	.globl _S0MODE
                                    119 	.globl _SM00
                                    120 	.globl _SM0
                                    121 	.globl _SM10
                                    122 	.globl _SM1
                                    123 	.globl _MCE0
                                    124 	.globl _SM20
                                    125 	.globl _SM2
                                    126 	.globl _REN0
                                    127 	.globl _REN
                                    128 	.globl _TB80
                                    129 	.globl _TB8
                                    130 	.globl _RB80
                                    131 	.globl _RB8
                                    132 	.globl _TI0
                                    133 	.globl _TI
                                    134 	.globl _RI0
                                    135 	.globl _RI
                                    136 	.globl _P1_7
                                    137 	.globl _P1_6
                                    138 	.globl _P1_5
                                    139 	.globl _P1_4
                                    140 	.globl _P1_3
                                    141 	.globl _P1_2
                                    142 	.globl _P1_1
                                    143 	.globl _P1_0
                                    144 	.globl _TF1
                                    145 	.globl _TR1
                                    146 	.globl _TF0
                                    147 	.globl _TR0
                                    148 	.globl _IE1
                                    149 	.globl _IT1
                                    150 	.globl _IE0
                                    151 	.globl _IT0
                                    152 	.globl _P0_7
                                    153 	.globl _P0_6
                                    154 	.globl _P0_5
                                    155 	.globl _P0_4
                                    156 	.globl _P0_3
                                    157 	.globl _P0_2
                                    158 	.globl _P0_1
                                    159 	.globl _P0_0
                                    160 	.globl _PCA0CP4
                                    161 	.globl _PCA0CP3
                                    162 	.globl _PCA0CP2
                                    163 	.globl _PCA0CP1
                                    164 	.globl _PCA0CP0
                                    165 	.globl _PCA0
                                    166 	.globl _DAC1
                                    167 	.globl _DAC0
                                    168 	.globl _ADC0LT
                                    169 	.globl _ADC0GT
                                    170 	.globl _ADC0
                                    171 	.globl _RCAP4
                                    172 	.globl _TMR4
                                    173 	.globl _TMR3RL
                                    174 	.globl _TMR3
                                    175 	.globl _RCAP2
                                    176 	.globl _TMR2
                                    177 	.globl _TMR1
                                    178 	.globl _TMR0
                                    179 	.globl _WDTCN
                                    180 	.globl _PCA0CPH4
                                    181 	.globl _PCA0CPH3
                                    182 	.globl _PCA0CPH2
                                    183 	.globl _PCA0CPH1
                                    184 	.globl _PCA0CPH0
                                    185 	.globl _PCA0H
                                    186 	.globl _SPI0CN
                                    187 	.globl _EIP2
                                    188 	.globl _EIP1
                                    189 	.globl _TH4
                                    190 	.globl _TL4
                                    191 	.globl _SADDR1
                                    192 	.globl _SBUF1
                                    193 	.globl _SCON1
                                    194 	.globl _B
                                    195 	.globl _RSTSRC
                                    196 	.globl _PCA0CPL4
                                    197 	.globl _PCA0CPL3
                                    198 	.globl _PCA0CPL2
                                    199 	.globl _PCA0CPL1
                                    200 	.globl _PCA0CPL0
                                    201 	.globl _PCA0L
                                    202 	.globl _ADC0CN
                                    203 	.globl _EIE2
                                    204 	.globl _EIE1
                                    205 	.globl _RCAP4H
                                    206 	.globl _RCAP4L
                                    207 	.globl _XBR2
                                    208 	.globl _XBR1
                                    209 	.globl _XBR0
                                    210 	.globl _ACC
                                    211 	.globl _PCA0CPM4
                                    212 	.globl _PCA0CPM3
                                    213 	.globl _PCA0CPM2
                                    214 	.globl _PCA0CPM1
                                    215 	.globl _PCA0CPM0
                                    216 	.globl _PCA0MD
                                    217 	.globl _PCA0CN
                                    218 	.globl _DAC1CN
                                    219 	.globl _DAC1H
                                    220 	.globl _DAC1L
                                    221 	.globl _DAC0CN
                                    222 	.globl _DAC0H
                                    223 	.globl _DAC0L
                                    224 	.globl _REF0CN
                                    225 	.globl _PSW
                                    226 	.globl _SMB0CR
                                    227 	.globl _TH2
                                    228 	.globl _TL2
                                    229 	.globl _RCAP2H
                                    230 	.globl _RCAP2L
                                    231 	.globl _T4CON
                                    232 	.globl _T2CON
                                    233 	.globl _ADC0LTH
                                    234 	.globl _ADC0LTL
                                    235 	.globl _ADC0GTH
                                    236 	.globl _ADC0GTL
                                    237 	.globl _SMB0ADR
                                    238 	.globl _SMB0DAT
                                    239 	.globl _SMB0STA
                                    240 	.globl _SMB0CN
                                    241 	.globl _ADC0H
                                    242 	.globl _ADC0L
                                    243 	.globl _P1MDIN
                                    244 	.globl _ADC0CF
                                    245 	.globl _AMX0SL
                                    246 	.globl _AMX0CF
                                    247 	.globl _SADEN0
                                    248 	.globl _IP
                                    249 	.globl _FLACL
                                    250 	.globl _FLSCL
                                    251 	.globl _P74OUT
                                    252 	.globl _OSCICN
                                    253 	.globl _OSCXCN
                                    254 	.globl _P3
                                    255 	.globl __XPAGE
                                    256 	.globl _EMI0CN
                                    257 	.globl _SADEN1
                                    258 	.globl _P3IF
                                    259 	.globl _AMX1SL
                                    260 	.globl _ADC1CF
                                    261 	.globl _ADC1CN
                                    262 	.globl _SADDR0
                                    263 	.globl _IE
                                    264 	.globl _P3MDOUT
                                    265 	.globl _PRT3CF
                                    266 	.globl _P2MDOUT
                                    267 	.globl _PRT2CF
                                    268 	.globl _P1MDOUT
                                    269 	.globl _PRT1CF
                                    270 	.globl _P0MDOUT
                                    271 	.globl _PRT0CF
                                    272 	.globl _EMI0CF
                                    273 	.globl _EMI0TC
                                    274 	.globl _P2
                                    275 	.globl _CPT1CN
                                    276 	.globl _CPT0CN
                                    277 	.globl _SPI0CKR
                                    278 	.globl _ADC1
                                    279 	.globl _SPI0DAT
                                    280 	.globl _SPI0CFG
                                    281 	.globl _SBUF0
                                    282 	.globl _SBUF
                                    283 	.globl _SCON0
                                    284 	.globl _SCON
                                    285 	.globl _P7
                                    286 	.globl _TMR3H
                                    287 	.globl _TMR3L
                                    288 	.globl _TMR3RLH
                                    289 	.globl _TMR3RLL
                                    290 	.globl _TMR3CN
                                    291 	.globl _P1
                                    292 	.globl _PSCTL
                                    293 	.globl _CKCON
                                    294 	.globl _TH1
                                    295 	.globl _TH0
                                    296 	.globl _TL1
                                    297 	.globl _TL0
                                    298 	.globl _TMOD
                                    299 	.globl _TCON
                                    300 	.globl _PCON
                                    301 	.globl _P6
                                    302 	.globl _P5
                                    303 	.globl _P4
                                    304 	.globl _DPH
                                    305 	.globl _DPL
                                    306 	.globl _SP
                                    307 	.globl _P0
                                    308 	.globl _RANGER_PW
                                    309 	.globl _COMPASS_PW
                                    310 	.globl _heading_delay
                                    311 	.globl _desired_range
                                    312 	.globl _desired_heading
                                    313 	.globl _h_count
                                    314 	.globl _r_count
                                    315 	.globl _range
                                    316 	.globl _heading
                                    317 	.globl _new_range
                                    318 	.globl _new_heading
                                    319 	.globl _PCA_START
                                    320 	.globl _RANGER_MIN
                                    321 	.globl _RANGER_MAX
                                    322 	.globl _RANGER_CENTER
                                    323 	.globl _COMPASS_MIN
                                    324 	.globl _COMPASS_MAX
                                    325 	.globl _COMPASS_CENTER
                                    326 	.globl _i2c_read_data_PARM_4
                                    327 	.globl _i2c_read_data_PARM_3
                                    328 	.globl _i2c_read_data_PARM_2
                                    329 	.globl _i2c_write_data_PARM_4
                                    330 	.globl _i2c_write_data_PARM_3
                                    331 	.globl _i2c_write_data_PARM_2
                                    332 	.globl _lcd_print
                                    333 	.globl _lcd_clear
                                    334 	.globl _kpd_input
                                    335 	.globl _delay_time
                                    336 	.globl _i2c_start
                                    337 	.globl _i2c_write
                                    338 	.globl _i2c_write_and_stop
                                    339 	.globl _i2c_read
                                    340 	.globl _i2c_read_and_stop
                                    341 	.globl _i2c_write_data
                                    342 	.globl _i2c_read_data
                                    343 	.globl _Accel_Init
                                    344 	.globl _Port_Init
                                    345 	.globl _PCA_Init
                                    346 	.globl _PCA_ISR
                                    347 	.globl _SMB_Init
                                    348 	.globl _ADC_Init
                                    349 	.globl _Interrupt_Init
                                    350 	.globl _read_compass
                                    351 	.globl _set_servo_PWM
                                    352 	.globl _read_ranger
                                    353 	.globl _set_drive_PWM
                                    354 	.globl _pick_heading
                                    355 	.globl _servo_error
                                    356 	.globl _motor_error
                                    357 ;--------------------------------------------------------
                                    358 ; special function registers
                                    359 ;--------------------------------------------------------
                                    360 	.area RSEG    (ABS,DATA)
      000000                        361 	.org 0x0000
                           000080   362 G$P0$0$0 == 0x0080
                           000080   363 _P0	=	0x0080
                           000081   364 G$SP$0$0 == 0x0081
                           000081   365 _SP	=	0x0081
                           000082   366 G$DPL$0$0 == 0x0082
                           000082   367 _DPL	=	0x0082
                           000083   368 G$DPH$0$0 == 0x0083
                           000083   369 _DPH	=	0x0083
                           000084   370 G$P4$0$0 == 0x0084
                           000084   371 _P4	=	0x0084
                           000085   372 G$P5$0$0 == 0x0085
                           000085   373 _P5	=	0x0085
                           000086   374 G$P6$0$0 == 0x0086
                           000086   375 _P6	=	0x0086
                           000087   376 G$PCON$0$0 == 0x0087
                           000087   377 _PCON	=	0x0087
                           000088   378 G$TCON$0$0 == 0x0088
                           000088   379 _TCON	=	0x0088
                           000089   380 G$TMOD$0$0 == 0x0089
                           000089   381 _TMOD	=	0x0089
                           00008A   382 G$TL0$0$0 == 0x008a
                           00008A   383 _TL0	=	0x008a
                           00008B   384 G$TL1$0$0 == 0x008b
                           00008B   385 _TL1	=	0x008b
                           00008C   386 G$TH0$0$0 == 0x008c
                           00008C   387 _TH0	=	0x008c
                           00008D   388 G$TH1$0$0 == 0x008d
                           00008D   389 _TH1	=	0x008d
                           00008E   390 G$CKCON$0$0 == 0x008e
                           00008E   391 _CKCON	=	0x008e
                           00008F   392 G$PSCTL$0$0 == 0x008f
                           00008F   393 _PSCTL	=	0x008f
                           000090   394 G$P1$0$0 == 0x0090
                           000090   395 _P1	=	0x0090
                           000091   396 G$TMR3CN$0$0 == 0x0091
                           000091   397 _TMR3CN	=	0x0091
                           000092   398 G$TMR3RLL$0$0 == 0x0092
                           000092   399 _TMR3RLL	=	0x0092
                           000093   400 G$TMR3RLH$0$0 == 0x0093
                           000093   401 _TMR3RLH	=	0x0093
                           000094   402 G$TMR3L$0$0 == 0x0094
                           000094   403 _TMR3L	=	0x0094
                           000095   404 G$TMR3H$0$0 == 0x0095
                           000095   405 _TMR3H	=	0x0095
                           000096   406 G$P7$0$0 == 0x0096
                           000096   407 _P7	=	0x0096
                           000098   408 G$SCON$0$0 == 0x0098
                           000098   409 _SCON	=	0x0098
                           000098   410 G$SCON0$0$0 == 0x0098
                           000098   411 _SCON0	=	0x0098
                           000099   412 G$SBUF$0$0 == 0x0099
                           000099   413 _SBUF	=	0x0099
                           000099   414 G$SBUF0$0$0 == 0x0099
                           000099   415 _SBUF0	=	0x0099
                           00009A   416 G$SPI0CFG$0$0 == 0x009a
                           00009A   417 _SPI0CFG	=	0x009a
                           00009B   418 G$SPI0DAT$0$0 == 0x009b
                           00009B   419 _SPI0DAT	=	0x009b
                           00009C   420 G$ADC1$0$0 == 0x009c
                           00009C   421 _ADC1	=	0x009c
                           00009D   422 G$SPI0CKR$0$0 == 0x009d
                           00009D   423 _SPI0CKR	=	0x009d
                           00009E   424 G$CPT0CN$0$0 == 0x009e
                           00009E   425 _CPT0CN	=	0x009e
                           00009F   426 G$CPT1CN$0$0 == 0x009f
                           00009F   427 _CPT1CN	=	0x009f
                           0000A0   428 G$P2$0$0 == 0x00a0
                           0000A0   429 _P2	=	0x00a0
                           0000A1   430 G$EMI0TC$0$0 == 0x00a1
                           0000A1   431 _EMI0TC	=	0x00a1
                           0000A3   432 G$EMI0CF$0$0 == 0x00a3
                           0000A3   433 _EMI0CF	=	0x00a3
                           0000A4   434 G$PRT0CF$0$0 == 0x00a4
                           0000A4   435 _PRT0CF	=	0x00a4
                           0000A4   436 G$P0MDOUT$0$0 == 0x00a4
                           0000A4   437 _P0MDOUT	=	0x00a4
                           0000A5   438 G$PRT1CF$0$0 == 0x00a5
                           0000A5   439 _PRT1CF	=	0x00a5
                           0000A5   440 G$P1MDOUT$0$0 == 0x00a5
                           0000A5   441 _P1MDOUT	=	0x00a5
                           0000A6   442 G$PRT2CF$0$0 == 0x00a6
                           0000A6   443 _PRT2CF	=	0x00a6
                           0000A6   444 G$P2MDOUT$0$0 == 0x00a6
                           0000A6   445 _P2MDOUT	=	0x00a6
                           0000A7   446 G$PRT3CF$0$0 == 0x00a7
                           0000A7   447 _PRT3CF	=	0x00a7
                           0000A7   448 G$P3MDOUT$0$0 == 0x00a7
                           0000A7   449 _P3MDOUT	=	0x00a7
                           0000A8   450 G$IE$0$0 == 0x00a8
                           0000A8   451 _IE	=	0x00a8
                           0000A9   452 G$SADDR0$0$0 == 0x00a9
                           0000A9   453 _SADDR0	=	0x00a9
                           0000AA   454 G$ADC1CN$0$0 == 0x00aa
                           0000AA   455 _ADC1CN	=	0x00aa
                           0000AB   456 G$ADC1CF$0$0 == 0x00ab
                           0000AB   457 _ADC1CF	=	0x00ab
                           0000AC   458 G$AMX1SL$0$0 == 0x00ac
                           0000AC   459 _AMX1SL	=	0x00ac
                           0000AD   460 G$P3IF$0$0 == 0x00ad
                           0000AD   461 _P3IF	=	0x00ad
                           0000AE   462 G$SADEN1$0$0 == 0x00ae
                           0000AE   463 _SADEN1	=	0x00ae
                           0000AF   464 G$EMI0CN$0$0 == 0x00af
                           0000AF   465 _EMI0CN	=	0x00af
                           0000AF   466 G$_XPAGE$0$0 == 0x00af
                           0000AF   467 __XPAGE	=	0x00af
                           0000B0   468 G$P3$0$0 == 0x00b0
                           0000B0   469 _P3	=	0x00b0
                           0000B1   470 G$OSCXCN$0$0 == 0x00b1
                           0000B1   471 _OSCXCN	=	0x00b1
                           0000B2   472 G$OSCICN$0$0 == 0x00b2
                           0000B2   473 _OSCICN	=	0x00b2
                           0000B5   474 G$P74OUT$0$0 == 0x00b5
                           0000B5   475 _P74OUT	=	0x00b5
                           0000B6   476 G$FLSCL$0$0 == 0x00b6
                           0000B6   477 _FLSCL	=	0x00b6
                           0000B7   478 G$FLACL$0$0 == 0x00b7
                           0000B7   479 _FLACL	=	0x00b7
                           0000B8   480 G$IP$0$0 == 0x00b8
                           0000B8   481 _IP	=	0x00b8
                           0000B9   482 G$SADEN0$0$0 == 0x00b9
                           0000B9   483 _SADEN0	=	0x00b9
                           0000BA   484 G$AMX0CF$0$0 == 0x00ba
                           0000BA   485 _AMX0CF	=	0x00ba
                           0000BB   486 G$AMX0SL$0$0 == 0x00bb
                           0000BB   487 _AMX0SL	=	0x00bb
                           0000BC   488 G$ADC0CF$0$0 == 0x00bc
                           0000BC   489 _ADC0CF	=	0x00bc
                           0000BD   490 G$P1MDIN$0$0 == 0x00bd
                           0000BD   491 _P1MDIN	=	0x00bd
                           0000BE   492 G$ADC0L$0$0 == 0x00be
                           0000BE   493 _ADC0L	=	0x00be
                           0000BF   494 G$ADC0H$0$0 == 0x00bf
                           0000BF   495 _ADC0H	=	0x00bf
                           0000C0   496 G$SMB0CN$0$0 == 0x00c0
                           0000C0   497 _SMB0CN	=	0x00c0
                           0000C1   498 G$SMB0STA$0$0 == 0x00c1
                           0000C1   499 _SMB0STA	=	0x00c1
                           0000C2   500 G$SMB0DAT$0$0 == 0x00c2
                           0000C2   501 _SMB0DAT	=	0x00c2
                           0000C3   502 G$SMB0ADR$0$0 == 0x00c3
                           0000C3   503 _SMB0ADR	=	0x00c3
                           0000C4   504 G$ADC0GTL$0$0 == 0x00c4
                           0000C4   505 _ADC0GTL	=	0x00c4
                           0000C5   506 G$ADC0GTH$0$0 == 0x00c5
                           0000C5   507 _ADC0GTH	=	0x00c5
                           0000C6   508 G$ADC0LTL$0$0 == 0x00c6
                           0000C6   509 _ADC0LTL	=	0x00c6
                           0000C7   510 G$ADC0LTH$0$0 == 0x00c7
                           0000C7   511 _ADC0LTH	=	0x00c7
                           0000C8   512 G$T2CON$0$0 == 0x00c8
                           0000C8   513 _T2CON	=	0x00c8
                           0000C9   514 G$T4CON$0$0 == 0x00c9
                           0000C9   515 _T4CON	=	0x00c9
                           0000CA   516 G$RCAP2L$0$0 == 0x00ca
                           0000CA   517 _RCAP2L	=	0x00ca
                           0000CB   518 G$RCAP2H$0$0 == 0x00cb
                           0000CB   519 _RCAP2H	=	0x00cb
                           0000CC   520 G$TL2$0$0 == 0x00cc
                           0000CC   521 _TL2	=	0x00cc
                           0000CD   522 G$TH2$0$0 == 0x00cd
                           0000CD   523 _TH2	=	0x00cd
                           0000CF   524 G$SMB0CR$0$0 == 0x00cf
                           0000CF   525 _SMB0CR	=	0x00cf
                           0000D0   526 G$PSW$0$0 == 0x00d0
                           0000D0   527 _PSW	=	0x00d0
                           0000D1   528 G$REF0CN$0$0 == 0x00d1
                           0000D1   529 _REF0CN	=	0x00d1
                           0000D2   530 G$DAC0L$0$0 == 0x00d2
                           0000D2   531 _DAC0L	=	0x00d2
                           0000D3   532 G$DAC0H$0$0 == 0x00d3
                           0000D3   533 _DAC0H	=	0x00d3
                           0000D4   534 G$DAC0CN$0$0 == 0x00d4
                           0000D4   535 _DAC0CN	=	0x00d4
                           0000D5   536 G$DAC1L$0$0 == 0x00d5
                           0000D5   537 _DAC1L	=	0x00d5
                           0000D6   538 G$DAC1H$0$0 == 0x00d6
                           0000D6   539 _DAC1H	=	0x00d6
                           0000D7   540 G$DAC1CN$0$0 == 0x00d7
                           0000D7   541 _DAC1CN	=	0x00d7
                           0000D8   542 G$PCA0CN$0$0 == 0x00d8
                           0000D8   543 _PCA0CN	=	0x00d8
                           0000D9   544 G$PCA0MD$0$0 == 0x00d9
                           0000D9   545 _PCA0MD	=	0x00d9
                           0000DA   546 G$PCA0CPM0$0$0 == 0x00da
                           0000DA   547 _PCA0CPM0	=	0x00da
                           0000DB   548 G$PCA0CPM1$0$0 == 0x00db
                           0000DB   549 _PCA0CPM1	=	0x00db
                           0000DC   550 G$PCA0CPM2$0$0 == 0x00dc
                           0000DC   551 _PCA0CPM2	=	0x00dc
                           0000DD   552 G$PCA0CPM3$0$0 == 0x00dd
                           0000DD   553 _PCA0CPM3	=	0x00dd
                           0000DE   554 G$PCA0CPM4$0$0 == 0x00de
                           0000DE   555 _PCA0CPM4	=	0x00de
                           0000E0   556 G$ACC$0$0 == 0x00e0
                           0000E0   557 _ACC	=	0x00e0
                           0000E1   558 G$XBR0$0$0 == 0x00e1
                           0000E1   559 _XBR0	=	0x00e1
                           0000E2   560 G$XBR1$0$0 == 0x00e2
                           0000E2   561 _XBR1	=	0x00e2
                           0000E3   562 G$XBR2$0$0 == 0x00e3
                           0000E3   563 _XBR2	=	0x00e3
                           0000E4   564 G$RCAP4L$0$0 == 0x00e4
                           0000E4   565 _RCAP4L	=	0x00e4
                           0000E5   566 G$RCAP4H$0$0 == 0x00e5
                           0000E5   567 _RCAP4H	=	0x00e5
                           0000E6   568 G$EIE1$0$0 == 0x00e6
                           0000E6   569 _EIE1	=	0x00e6
                           0000E7   570 G$EIE2$0$0 == 0x00e7
                           0000E7   571 _EIE2	=	0x00e7
                           0000E8   572 G$ADC0CN$0$0 == 0x00e8
                           0000E8   573 _ADC0CN	=	0x00e8
                           0000E9   574 G$PCA0L$0$0 == 0x00e9
                           0000E9   575 _PCA0L	=	0x00e9
                           0000EA   576 G$PCA0CPL0$0$0 == 0x00ea
                           0000EA   577 _PCA0CPL0	=	0x00ea
                           0000EB   578 G$PCA0CPL1$0$0 == 0x00eb
                           0000EB   579 _PCA0CPL1	=	0x00eb
                           0000EC   580 G$PCA0CPL2$0$0 == 0x00ec
                           0000EC   581 _PCA0CPL2	=	0x00ec
                           0000ED   582 G$PCA0CPL3$0$0 == 0x00ed
                           0000ED   583 _PCA0CPL3	=	0x00ed
                           0000EE   584 G$PCA0CPL4$0$0 == 0x00ee
                           0000EE   585 _PCA0CPL4	=	0x00ee
                           0000EF   586 G$RSTSRC$0$0 == 0x00ef
                           0000EF   587 _RSTSRC	=	0x00ef
                           0000F0   588 G$B$0$0 == 0x00f0
                           0000F0   589 _B	=	0x00f0
                           0000F1   590 G$SCON1$0$0 == 0x00f1
                           0000F1   591 _SCON1	=	0x00f1
                           0000F2   592 G$SBUF1$0$0 == 0x00f2
                           0000F2   593 _SBUF1	=	0x00f2
                           0000F3   594 G$SADDR1$0$0 == 0x00f3
                           0000F3   595 _SADDR1	=	0x00f3
                           0000F4   596 G$TL4$0$0 == 0x00f4
                           0000F4   597 _TL4	=	0x00f4
                           0000F5   598 G$TH4$0$0 == 0x00f5
                           0000F5   599 _TH4	=	0x00f5
                           0000F6   600 G$EIP1$0$0 == 0x00f6
                           0000F6   601 _EIP1	=	0x00f6
                           0000F7   602 G$EIP2$0$0 == 0x00f7
                           0000F7   603 _EIP2	=	0x00f7
                           0000F8   604 G$SPI0CN$0$0 == 0x00f8
                           0000F8   605 _SPI0CN	=	0x00f8
                           0000F9   606 G$PCA0H$0$0 == 0x00f9
                           0000F9   607 _PCA0H	=	0x00f9
                           0000FA   608 G$PCA0CPH0$0$0 == 0x00fa
                           0000FA   609 _PCA0CPH0	=	0x00fa
                           0000FB   610 G$PCA0CPH1$0$0 == 0x00fb
                           0000FB   611 _PCA0CPH1	=	0x00fb
                           0000FC   612 G$PCA0CPH2$0$0 == 0x00fc
                           0000FC   613 _PCA0CPH2	=	0x00fc
                           0000FD   614 G$PCA0CPH3$0$0 == 0x00fd
                           0000FD   615 _PCA0CPH3	=	0x00fd
                           0000FE   616 G$PCA0CPH4$0$0 == 0x00fe
                           0000FE   617 _PCA0CPH4	=	0x00fe
                           0000FF   618 G$WDTCN$0$0 == 0x00ff
                           0000FF   619 _WDTCN	=	0x00ff
                           008C8A   620 G$TMR0$0$0 == 0x8c8a
                           008C8A   621 _TMR0	=	0x8c8a
                           008D8B   622 G$TMR1$0$0 == 0x8d8b
                           008D8B   623 _TMR1	=	0x8d8b
                           00CDCC   624 G$TMR2$0$0 == 0xcdcc
                           00CDCC   625 _TMR2	=	0xcdcc
                           00CBCA   626 G$RCAP2$0$0 == 0xcbca
                           00CBCA   627 _RCAP2	=	0xcbca
                           009594   628 G$TMR3$0$0 == 0x9594
                           009594   629 _TMR3	=	0x9594
                           009392   630 G$TMR3RL$0$0 == 0x9392
                           009392   631 _TMR3RL	=	0x9392
                           00F5F4   632 G$TMR4$0$0 == 0xf5f4
                           00F5F4   633 _TMR4	=	0xf5f4
                           00E5E4   634 G$RCAP4$0$0 == 0xe5e4
                           00E5E4   635 _RCAP4	=	0xe5e4
                           00BFBE   636 G$ADC0$0$0 == 0xbfbe
                           00BFBE   637 _ADC0	=	0xbfbe
                           00C5C4   638 G$ADC0GT$0$0 == 0xc5c4
                           00C5C4   639 _ADC0GT	=	0xc5c4
                           00C7C6   640 G$ADC0LT$0$0 == 0xc7c6
                           00C7C6   641 _ADC0LT	=	0xc7c6
                           00D3D2   642 G$DAC0$0$0 == 0xd3d2
                           00D3D2   643 _DAC0	=	0xd3d2
                           00D6D5   644 G$DAC1$0$0 == 0xd6d5
                           00D6D5   645 _DAC1	=	0xd6d5
                           00F9E9   646 G$PCA0$0$0 == 0xf9e9
                           00F9E9   647 _PCA0	=	0xf9e9
                           00FAEA   648 G$PCA0CP0$0$0 == 0xfaea
                           00FAEA   649 _PCA0CP0	=	0xfaea
                           00FBEB   650 G$PCA0CP1$0$0 == 0xfbeb
                           00FBEB   651 _PCA0CP1	=	0xfbeb
                           00FCEC   652 G$PCA0CP2$0$0 == 0xfcec
                           00FCEC   653 _PCA0CP2	=	0xfcec
                           00FDED   654 G$PCA0CP3$0$0 == 0xfded
                           00FDED   655 _PCA0CP3	=	0xfded
                           00FEEE   656 G$PCA0CP4$0$0 == 0xfeee
                           00FEEE   657 _PCA0CP4	=	0xfeee
                                    658 ;--------------------------------------------------------
                                    659 ; special function bits
                                    660 ;--------------------------------------------------------
                                    661 	.area RSEG    (ABS,DATA)
      000000                        662 	.org 0x0000
                           000080   663 G$P0_0$0$0 == 0x0080
                           000080   664 _P0_0	=	0x0080
                           000081   665 G$P0_1$0$0 == 0x0081
                           000081   666 _P0_1	=	0x0081
                           000082   667 G$P0_2$0$0 == 0x0082
                           000082   668 _P0_2	=	0x0082
                           000083   669 G$P0_3$0$0 == 0x0083
                           000083   670 _P0_3	=	0x0083
                           000084   671 G$P0_4$0$0 == 0x0084
                           000084   672 _P0_4	=	0x0084
                           000085   673 G$P0_5$0$0 == 0x0085
                           000085   674 _P0_5	=	0x0085
                           000086   675 G$P0_6$0$0 == 0x0086
                           000086   676 _P0_6	=	0x0086
                           000087   677 G$P0_7$0$0 == 0x0087
                           000087   678 _P0_7	=	0x0087
                           000088   679 G$IT0$0$0 == 0x0088
                           000088   680 _IT0	=	0x0088
                           000089   681 G$IE0$0$0 == 0x0089
                           000089   682 _IE0	=	0x0089
                           00008A   683 G$IT1$0$0 == 0x008a
                           00008A   684 _IT1	=	0x008a
                           00008B   685 G$IE1$0$0 == 0x008b
                           00008B   686 _IE1	=	0x008b
                           00008C   687 G$TR0$0$0 == 0x008c
                           00008C   688 _TR0	=	0x008c
                           00008D   689 G$TF0$0$0 == 0x008d
                           00008D   690 _TF0	=	0x008d
                           00008E   691 G$TR1$0$0 == 0x008e
                           00008E   692 _TR1	=	0x008e
                           00008F   693 G$TF1$0$0 == 0x008f
                           00008F   694 _TF1	=	0x008f
                           000090   695 G$P1_0$0$0 == 0x0090
                           000090   696 _P1_0	=	0x0090
                           000091   697 G$P1_1$0$0 == 0x0091
                           000091   698 _P1_1	=	0x0091
                           000092   699 G$P1_2$0$0 == 0x0092
                           000092   700 _P1_2	=	0x0092
                           000093   701 G$P1_3$0$0 == 0x0093
                           000093   702 _P1_3	=	0x0093
                           000094   703 G$P1_4$0$0 == 0x0094
                           000094   704 _P1_4	=	0x0094
                           000095   705 G$P1_5$0$0 == 0x0095
                           000095   706 _P1_5	=	0x0095
                           000096   707 G$P1_6$0$0 == 0x0096
                           000096   708 _P1_6	=	0x0096
                           000097   709 G$P1_7$0$0 == 0x0097
                           000097   710 _P1_7	=	0x0097
                           000098   711 G$RI$0$0 == 0x0098
                           000098   712 _RI	=	0x0098
                           000098   713 G$RI0$0$0 == 0x0098
                           000098   714 _RI0	=	0x0098
                           000099   715 G$TI$0$0 == 0x0099
                           000099   716 _TI	=	0x0099
                           000099   717 G$TI0$0$0 == 0x0099
                           000099   718 _TI0	=	0x0099
                           00009A   719 G$RB8$0$0 == 0x009a
                           00009A   720 _RB8	=	0x009a
                           00009A   721 G$RB80$0$0 == 0x009a
                           00009A   722 _RB80	=	0x009a
                           00009B   723 G$TB8$0$0 == 0x009b
                           00009B   724 _TB8	=	0x009b
                           00009B   725 G$TB80$0$0 == 0x009b
                           00009B   726 _TB80	=	0x009b
                           00009C   727 G$REN$0$0 == 0x009c
                           00009C   728 _REN	=	0x009c
                           00009C   729 G$REN0$0$0 == 0x009c
                           00009C   730 _REN0	=	0x009c
                           00009D   731 G$SM2$0$0 == 0x009d
                           00009D   732 _SM2	=	0x009d
                           00009D   733 G$SM20$0$0 == 0x009d
                           00009D   734 _SM20	=	0x009d
                           00009D   735 G$MCE0$0$0 == 0x009d
                           00009D   736 _MCE0	=	0x009d
                           00009E   737 G$SM1$0$0 == 0x009e
                           00009E   738 _SM1	=	0x009e
                           00009E   739 G$SM10$0$0 == 0x009e
                           00009E   740 _SM10	=	0x009e
                           00009F   741 G$SM0$0$0 == 0x009f
                           00009F   742 _SM0	=	0x009f
                           00009F   743 G$SM00$0$0 == 0x009f
                           00009F   744 _SM00	=	0x009f
                           00009F   745 G$S0MODE$0$0 == 0x009f
                           00009F   746 _S0MODE	=	0x009f
                           0000A0   747 G$P2_0$0$0 == 0x00a0
                           0000A0   748 _P2_0	=	0x00a0
                           0000A1   749 G$P2_1$0$0 == 0x00a1
                           0000A1   750 _P2_1	=	0x00a1
                           0000A2   751 G$P2_2$0$0 == 0x00a2
                           0000A2   752 _P2_2	=	0x00a2
                           0000A3   753 G$P2_3$0$0 == 0x00a3
                           0000A3   754 _P2_3	=	0x00a3
                           0000A4   755 G$P2_4$0$0 == 0x00a4
                           0000A4   756 _P2_4	=	0x00a4
                           0000A5   757 G$P2_5$0$0 == 0x00a5
                           0000A5   758 _P2_5	=	0x00a5
                           0000A6   759 G$P2_6$0$0 == 0x00a6
                           0000A6   760 _P2_6	=	0x00a6
                           0000A7   761 G$P2_7$0$0 == 0x00a7
                           0000A7   762 _P2_7	=	0x00a7
                           0000A8   763 G$EX0$0$0 == 0x00a8
                           0000A8   764 _EX0	=	0x00a8
                           0000A9   765 G$ET0$0$0 == 0x00a9
                           0000A9   766 _ET0	=	0x00a9
                           0000AA   767 G$EX1$0$0 == 0x00aa
                           0000AA   768 _EX1	=	0x00aa
                           0000AB   769 G$ET1$0$0 == 0x00ab
                           0000AB   770 _ET1	=	0x00ab
                           0000AC   771 G$ES0$0$0 == 0x00ac
                           0000AC   772 _ES0	=	0x00ac
                           0000AC   773 G$ES$0$0 == 0x00ac
                           0000AC   774 _ES	=	0x00ac
                           0000AD   775 G$ET2$0$0 == 0x00ad
                           0000AD   776 _ET2	=	0x00ad
                           0000AF   777 G$EA$0$0 == 0x00af
                           0000AF   778 _EA	=	0x00af
                           0000B0   779 G$P3_0$0$0 == 0x00b0
                           0000B0   780 _P3_0	=	0x00b0
                           0000B1   781 G$P3_1$0$0 == 0x00b1
                           0000B1   782 _P3_1	=	0x00b1
                           0000B2   783 G$P3_2$0$0 == 0x00b2
                           0000B2   784 _P3_2	=	0x00b2
                           0000B3   785 G$P3_3$0$0 == 0x00b3
                           0000B3   786 _P3_3	=	0x00b3
                           0000B4   787 G$P3_4$0$0 == 0x00b4
                           0000B4   788 _P3_4	=	0x00b4
                           0000B5   789 G$P3_5$0$0 == 0x00b5
                           0000B5   790 _P3_5	=	0x00b5
                           0000B6   791 G$P3_6$0$0 == 0x00b6
                           0000B6   792 _P3_6	=	0x00b6
                           0000B7   793 G$P3_7$0$0 == 0x00b7
                           0000B7   794 _P3_7	=	0x00b7
                           0000B8   795 G$PX0$0$0 == 0x00b8
                           0000B8   796 _PX0	=	0x00b8
                           0000B9   797 G$PT0$0$0 == 0x00b9
                           0000B9   798 _PT0	=	0x00b9
                           0000BA   799 G$PX1$0$0 == 0x00ba
                           0000BA   800 _PX1	=	0x00ba
                           0000BB   801 G$PT1$0$0 == 0x00bb
                           0000BB   802 _PT1	=	0x00bb
                           0000BC   803 G$PS0$0$0 == 0x00bc
                           0000BC   804 _PS0	=	0x00bc
                           0000BC   805 G$PS$0$0 == 0x00bc
                           0000BC   806 _PS	=	0x00bc
                           0000BD   807 G$PT2$0$0 == 0x00bd
                           0000BD   808 _PT2	=	0x00bd
                           0000C0   809 G$SMBTOE$0$0 == 0x00c0
                           0000C0   810 _SMBTOE	=	0x00c0
                           0000C1   811 G$SMBFTE$0$0 == 0x00c1
                           0000C1   812 _SMBFTE	=	0x00c1
                           0000C2   813 G$AA$0$0 == 0x00c2
                           0000C2   814 _AA	=	0x00c2
                           0000C3   815 G$SI$0$0 == 0x00c3
                           0000C3   816 _SI	=	0x00c3
                           0000C4   817 G$STO$0$0 == 0x00c4
                           0000C4   818 _STO	=	0x00c4
                           0000C5   819 G$STA$0$0 == 0x00c5
                           0000C5   820 _STA	=	0x00c5
                           0000C6   821 G$ENSMB$0$0 == 0x00c6
                           0000C6   822 _ENSMB	=	0x00c6
                           0000C7   823 G$BUSY$0$0 == 0x00c7
                           0000C7   824 _BUSY	=	0x00c7
                           0000C8   825 G$CPRL2$0$0 == 0x00c8
                           0000C8   826 _CPRL2	=	0x00c8
                           0000C9   827 G$CT2$0$0 == 0x00c9
                           0000C9   828 _CT2	=	0x00c9
                           0000CA   829 G$TR2$0$0 == 0x00ca
                           0000CA   830 _TR2	=	0x00ca
                           0000CB   831 G$EXEN2$0$0 == 0x00cb
                           0000CB   832 _EXEN2	=	0x00cb
                           0000CC   833 G$TCLK$0$0 == 0x00cc
                           0000CC   834 _TCLK	=	0x00cc
                           0000CD   835 G$RCLK$0$0 == 0x00cd
                           0000CD   836 _RCLK	=	0x00cd
                           0000CE   837 G$EXF2$0$0 == 0x00ce
                           0000CE   838 _EXF2	=	0x00ce
                           0000CF   839 G$TF2$0$0 == 0x00cf
                           0000CF   840 _TF2	=	0x00cf
                           0000D0   841 G$P$0$0 == 0x00d0
                           0000D0   842 _P	=	0x00d0
                           0000D1   843 G$F1$0$0 == 0x00d1
                           0000D1   844 _F1	=	0x00d1
                           0000D2   845 G$OV$0$0 == 0x00d2
                           0000D2   846 _OV	=	0x00d2
                           0000D3   847 G$RS0$0$0 == 0x00d3
                           0000D3   848 _RS0	=	0x00d3
                           0000D4   849 G$RS1$0$0 == 0x00d4
                           0000D4   850 _RS1	=	0x00d4
                           0000D5   851 G$F0$0$0 == 0x00d5
                           0000D5   852 _F0	=	0x00d5
                           0000D6   853 G$AC$0$0 == 0x00d6
                           0000D6   854 _AC	=	0x00d6
                           0000D7   855 G$CY$0$0 == 0x00d7
                           0000D7   856 _CY	=	0x00d7
                           0000D8   857 G$CCF0$0$0 == 0x00d8
                           0000D8   858 _CCF0	=	0x00d8
                           0000D9   859 G$CCF1$0$0 == 0x00d9
                           0000D9   860 _CCF1	=	0x00d9
                           0000DA   861 G$CCF2$0$0 == 0x00da
                           0000DA   862 _CCF2	=	0x00da
                           0000DB   863 G$CCF3$0$0 == 0x00db
                           0000DB   864 _CCF3	=	0x00db
                           0000DC   865 G$CCF4$0$0 == 0x00dc
                           0000DC   866 _CCF4	=	0x00dc
                           0000DE   867 G$CR$0$0 == 0x00de
                           0000DE   868 _CR	=	0x00de
                           0000DF   869 G$CF$0$0 == 0x00df
                           0000DF   870 _CF	=	0x00df
                           0000E8   871 G$ADLJST$0$0 == 0x00e8
                           0000E8   872 _ADLJST	=	0x00e8
                           0000E8   873 G$AD0LJST$0$0 == 0x00e8
                           0000E8   874 _AD0LJST	=	0x00e8
                           0000E9   875 G$ADWINT$0$0 == 0x00e9
                           0000E9   876 _ADWINT	=	0x00e9
                           0000E9   877 G$AD0WINT$0$0 == 0x00e9
                           0000E9   878 _AD0WINT	=	0x00e9
                           0000EA   879 G$ADSTM0$0$0 == 0x00ea
                           0000EA   880 _ADSTM0	=	0x00ea
                           0000EA   881 G$AD0CM0$0$0 == 0x00ea
                           0000EA   882 _AD0CM0	=	0x00ea
                           0000EB   883 G$ADSTM1$0$0 == 0x00eb
                           0000EB   884 _ADSTM1	=	0x00eb
                           0000EB   885 G$AD0CM1$0$0 == 0x00eb
                           0000EB   886 _AD0CM1	=	0x00eb
                           0000EC   887 G$ADBUSY$0$0 == 0x00ec
                           0000EC   888 _ADBUSY	=	0x00ec
                           0000EC   889 G$AD0BUSY$0$0 == 0x00ec
                           0000EC   890 _AD0BUSY	=	0x00ec
                           0000ED   891 G$ADCINT$0$0 == 0x00ed
                           0000ED   892 _ADCINT	=	0x00ed
                           0000ED   893 G$AD0INT$0$0 == 0x00ed
                           0000ED   894 _AD0INT	=	0x00ed
                           0000EE   895 G$ADCTM$0$0 == 0x00ee
                           0000EE   896 _ADCTM	=	0x00ee
                           0000EE   897 G$AD0TM$0$0 == 0x00ee
                           0000EE   898 _AD0TM	=	0x00ee
                           0000EF   899 G$ADCEN$0$0 == 0x00ef
                           0000EF   900 _ADCEN	=	0x00ef
                           0000EF   901 G$AD0EN$0$0 == 0x00ef
                           0000EF   902 _AD0EN	=	0x00ef
                           0000F8   903 G$SPIEN$0$0 == 0x00f8
                           0000F8   904 _SPIEN	=	0x00f8
                           0000F9   905 G$MSTEN$0$0 == 0x00f9
                           0000F9   906 _MSTEN	=	0x00f9
                           0000FA   907 G$SLVSEL$0$0 == 0x00fa
                           0000FA   908 _SLVSEL	=	0x00fa
                           0000FB   909 G$TXBSY$0$0 == 0x00fb
                           0000FB   910 _TXBSY	=	0x00fb
                           0000FC   911 G$RXOVRN$0$0 == 0x00fc
                           0000FC   912 _RXOVRN	=	0x00fc
                           0000FD   913 G$MODF$0$0 == 0x00fd
                           0000FD   914 _MODF	=	0x00fd
                           0000FE   915 G$WCOL$0$0 == 0x00fe
                           0000FE   916 _WCOL	=	0x00fe
                           0000FF   917 G$SPIF$0$0 == 0x00ff
                           0000FF   918 _SPIF	=	0x00ff
                           0000C7   919 G$BUS_BUSY$0$0 == 0x00c7
                           0000C7   920 _BUS_BUSY	=	0x00c7
                           0000C6   921 G$BUS_EN$0$0 == 0x00c6
                           0000C6   922 _BUS_EN	=	0x00c6
                           0000C5   923 G$BUS_START$0$0 == 0x00c5
                           0000C5   924 _BUS_START	=	0x00c5
                           0000C4   925 G$BUS_STOP$0$0 == 0x00c4
                           0000C4   926 _BUS_STOP	=	0x00c4
                           0000C3   927 G$BUS_INT$0$0 == 0x00c3
                           0000C3   928 _BUS_INT	=	0x00c3
                           0000C2   929 G$BUS_AA$0$0 == 0x00c2
                           0000C2   930 _BUS_AA	=	0x00c2
                           0000C1   931 G$BUS_FTE$0$0 == 0x00c1
                           0000C1   932 _BUS_FTE	=	0x00c1
                           0000C0   933 G$BUS_TOE$0$0 == 0x00c0
                           0000C0   934 _BUS_TOE	=	0x00c0
                           000083   935 G$BUS_SCL$0$0 == 0x0083
                           000083   936 _BUS_SCL	=	0x0083
                           0000B7   937 G$COMPASS_SWITCH$0$0 == 0x00b7
                           0000B7   938 _COMPASS_SWITCH	=	0x00b7
                           0000B6   939 G$RANGER_SWITCH$0$0 == 0x00b6
                           0000B6   940 _RANGER_SWITCH	=	0x00b6
                                    941 ;--------------------------------------------------------
                                    942 ; overlayable register banks
                                    943 ;--------------------------------------------------------
                                    944 	.area REG_BANK_0	(REL,OVR,DATA)
      000000                        945 	.ds 8
                                    946 ;--------------------------------------------------------
                                    947 ; internal ram data
                                    948 ;--------------------------------------------------------
                                    949 	.area DSEG    (DATA)
                           000000   950 LLab_4.lcd_clear$NumBytes$1$77==.
      000000                        951 _lcd_clear_NumBytes_1_77:
      000000                        952 	.ds 1
                           000001   953 LLab_4.lcd_clear$Cmd$1$77==.
      000001                        954 _lcd_clear_Cmd_1_77:
      000001                        955 	.ds 2
                           000003   956 LLab_4.read_keypad$Data$1$78==.
      000003                        957 _read_keypad_Data_1_78:
      000003                        958 	.ds 2
                           000005   959 LLab_4.i2c_write_data$start_reg$1$97==.
      000005                        960 _i2c_write_data_PARM_2:
      000005                        961 	.ds 1
                           000006   962 LLab_4.i2c_write_data$buffer$1$97==.
      000006                        963 _i2c_write_data_PARM_3:
      000006                        964 	.ds 3
                           000009   965 LLab_4.i2c_write_data$num_bytes$1$97==.
      000009                        966 _i2c_write_data_PARM_4:
      000009                        967 	.ds 1
                           00000A   968 LLab_4.i2c_read_data$start_reg$1$99==.
      00000A                        969 _i2c_read_data_PARM_2:
      00000A                        970 	.ds 1
                           00000B   971 LLab_4.i2c_read_data$buffer$1$99==.
      00000B                        972 _i2c_read_data_PARM_3:
      00000B                        973 	.ds 3
                           00000E   974 LLab_4.i2c_read_data$num_bytes$1$99==.
      00000E                        975 _i2c_read_data_PARM_4:
      00000E                        976 	.ds 1
                           00000F   977 LLab_4.Accel_Init$Data2$1$103==.
      00000F                        978 _Accel_Init_Data2_1_103:
      00000F                        979 	.ds 1
                           000010   980 G$COMPASS_CENTER$0$0==.
      000010                        981 _COMPASS_CENTER::
      000010                        982 	.ds 2
                           000012   983 G$COMPASS_MAX$0$0==.
      000012                        984 _COMPASS_MAX::
      000012                        985 	.ds 2
                           000014   986 G$COMPASS_MIN$0$0==.
      000014                        987 _COMPASS_MIN::
      000014                        988 	.ds 2
                           000016   989 G$RANGER_CENTER$0$0==.
      000016                        990 _RANGER_CENTER::
      000016                        991 	.ds 2
                           000018   992 G$RANGER_MAX$0$0==.
      000018                        993 _RANGER_MAX::
      000018                        994 	.ds 2
                           00001A   995 G$RANGER_MIN$0$0==.
      00001A                        996 _RANGER_MIN::
      00001A                        997 	.ds 2
                           00001C   998 G$PCA_START$0$0==.
      00001C                        999 _PCA_START::
      00001C                       1000 	.ds 2
                           00001E  1001 G$new_heading$0$0==.
      00001E                       1002 _new_heading::
      00001E                       1003 	.ds 1
                           00001F  1004 G$new_range$0$0==.
      00001F                       1005 _new_range::
      00001F                       1006 	.ds 1
                           000020  1007 G$heading$0$0==.
      000020                       1008 _heading::
      000020                       1009 	.ds 2
                           000022  1010 G$range$0$0==.
      000022                       1011 _range::
      000022                       1012 	.ds 2
                           000024  1013 G$r_count$0$0==.
      000024                       1014 _r_count::
      000024                       1015 	.ds 1
                           000025  1016 G$h_count$0$0==.
      000025                       1017 _h_count::
      000025                       1018 	.ds 1
                           000026  1019 G$desired_heading$0$0==.
      000026                       1020 _desired_heading::
      000026                       1021 	.ds 2
                           000028  1022 G$desired_range$0$0==.
      000028                       1023 _desired_range::
      000028                       1024 	.ds 2
                           00002A  1025 G$heading_delay$0$0==.
      00002A                       1026 _heading_delay::
      00002A                       1027 	.ds 1
                           00002B  1028 G$COMPASS_PW$0$0==.
      00002B                       1029 _COMPASS_PW::
      00002B                       1030 	.ds 2
                           00002D  1031 G$RANGER_PW$0$0==.
      00002D                       1032 _RANGER_PW::
      00002D                       1033 	.ds 2
                           00002F  1034 LLab_4.read_compass$Data$1$140==.
      00002F                       1035 _read_compass_Data_1_140:
      00002F                       1036 	.ds 2
                           000031  1037 LLab_4.read_ranger$Data$1$145==.
      000031                       1038 _read_ranger_Data_1_145:
      000031                       1039 	.ds 2
                                   1040 ;--------------------------------------------------------
                                   1041 ; overlayable items in internal ram 
                                   1042 ;--------------------------------------------------------
                                   1043 	.area	OSEG    (OVR,DATA)
                                   1044 	.area	OSEG    (OVR,DATA)
                                   1045 	.area	OSEG    (OVR,DATA)
                                   1046 	.area	OSEG    (OVR,DATA)
                                   1047 	.area	OSEG    (OVR,DATA)
                                   1048 	.area	OSEG    (OVR,DATA)
                                   1049 	.area	OSEG    (OVR,DATA)
                                   1050 ;--------------------------------------------------------
                                   1051 ; Stack segment in internal ram 
                                   1052 ;--------------------------------------------------------
                                   1053 	.area	SSEG
      000000                       1054 __start__stack:
      000000                       1055 	.ds	1
                                   1056 
                                   1057 ;--------------------------------------------------------
                                   1058 ; indirectly addressable internal ram data
                                   1059 ;--------------------------------------------------------
                                   1060 	.area ISEG    (DATA)
                                   1061 ;--------------------------------------------------------
                                   1062 ; absolute internal ram data
                                   1063 ;--------------------------------------------------------
                                   1064 	.area IABS    (ABS,DATA)
                                   1065 	.area IABS    (ABS,DATA)
                                   1066 ;--------------------------------------------------------
                                   1067 ; bit data
                                   1068 ;--------------------------------------------------------
                                   1069 	.area BSEG    (BIT)
                                   1070 ;--------------------------------------------------------
                                   1071 ; paged external ram data
                                   1072 ;--------------------------------------------------------
                                   1073 	.area PSEG    (PAG,XDATA)
                                   1074 ;--------------------------------------------------------
                                   1075 ; external ram data
                                   1076 ;--------------------------------------------------------
                                   1077 	.area XSEG    (XDATA)
                           000000  1078 LLab_4.lcd_print$text$1$73==.
      000000                       1079 _lcd_print_text_1_73:
      000000                       1080 	.ds 80
                                   1081 ;--------------------------------------------------------
                                   1082 ; absolute external ram data
                                   1083 ;--------------------------------------------------------
                                   1084 	.area XABS    (ABS,XDATA)
                                   1085 ;--------------------------------------------------------
                                   1086 ; external initialized ram data
                                   1087 ;--------------------------------------------------------
                                   1088 	.area XISEG   (XDATA)
                                   1089 	.area HOME    (CODE)
                                   1090 	.area GSINIT0 (CODE)
                                   1091 	.area GSINIT1 (CODE)
                                   1092 	.area GSINIT2 (CODE)
                                   1093 	.area GSINIT3 (CODE)
                                   1094 	.area GSINIT4 (CODE)
                                   1095 	.area GSINIT5 (CODE)
                                   1096 	.area GSINIT  (CODE)
                                   1097 	.area GSFINAL (CODE)
                                   1098 	.area CSEG    (CODE)
                                   1099 ;--------------------------------------------------------
                                   1100 ; interrupt vector 
                                   1101 ;--------------------------------------------------------
                                   1102 	.area HOME    (CODE)
      000000                       1103 __interrupt_vect:
      000000 02r00r00         [24] 1104 	ljmp	__sdcc_gsinit_startup
      000003 32               [24] 1105 	reti
      000004                       1106 	.ds	7
      00000B 32               [24] 1107 	reti
      00000C                       1108 	.ds	7
      000013 32               [24] 1109 	reti
      000014                       1110 	.ds	7
      00001B 32               [24] 1111 	reti
      00001C                       1112 	.ds	7
      000023 32               [24] 1113 	reti
      000024                       1114 	.ds	7
      00002B 32               [24] 1115 	reti
      00002C                       1116 	.ds	7
      000033 32               [24] 1117 	reti
      000034                       1118 	.ds	7
      00003B 32               [24] 1119 	reti
      00003C                       1120 	.ds	7
      000043 32               [24] 1121 	reti
      000044                       1122 	.ds	7
      00004B 02r05r52         [24] 1123 	ljmp	_PCA_ISR
                                   1124 ;--------------------------------------------------------
                                   1125 ; global & static initialisations
                                   1126 ;--------------------------------------------------------
                                   1127 	.area HOME    (CODE)
                                   1128 	.area GSINIT  (CODE)
                                   1129 	.area GSFINAL (CODE)
                                   1130 	.area GSINIT  (CODE)
                                   1131 	.globl __sdcc_gsinit_startup
                                   1132 	.globl __sdcc_program_startup
                                   1133 	.globl __start__stack
                                   1134 	.globl __mcs51_genXINIT
                                   1135 	.globl __mcs51_genXRAMCLEAR
                                   1136 	.globl __mcs51_genRAMCLEAR
                           000000  1137 	C$Lab_4.c$37$1$156 ==.
                                   1138 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:37: unsigned int COMPASS_CENTER = 2760;
      000000 75*10 C8         [24] 1139 	mov	_COMPASS_CENTER,#0xC8
      000003 75*11 0A         [24] 1140 	mov	(_COMPASS_CENTER + 1),#0x0A
                           000006  1141 	C$Lab_4.c$38$1$156 ==.
                                   1142 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:38: unsigned int COMPASS_MAX = 3500;
      000006 75*12 AC         [24] 1143 	mov	_COMPASS_MAX,#0xAC
      000009 75*13 0D         [24] 1144 	mov	(_COMPASS_MAX + 1),#0x0D
                           00000C  1145 	C$Lab_4.c$39$1$156 ==.
                                   1146 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:39: unsigned int COMPASS_MIN = 2030;
      00000C 75*14 EE         [24] 1147 	mov	_COMPASS_MIN,#0xEE
      00000F 75*15 07         [24] 1148 	mov	(_COMPASS_MIN + 1),#0x07
                           000012  1149 	C$Lab_4.c$40$1$156 ==.
                                   1150 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:40: unsigned int RANGER_CENTER = 2760;
      000012 75*16 C8         [24] 1151 	mov	_RANGER_CENTER,#0xC8
      000015 75*17 0A         [24] 1152 	mov	(_RANGER_CENTER + 1),#0x0A
                           000018  1153 	C$Lab_4.c$41$1$156 ==.
                                   1154 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:41: unsigned int RANGER_MAX = 3500;
      000018 75*18 AC         [24] 1155 	mov	_RANGER_MAX,#0xAC
      00001B 75*19 0D         [24] 1156 	mov	(_RANGER_MAX + 1),#0x0D
                           00001E  1157 	C$Lab_4.c$42$1$156 ==.
                                   1158 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:42: unsigned int RANGER_MIN = 2030;
      00001E 75*1A EE         [24] 1159 	mov	_RANGER_MIN,#0xEE
      000021 75*1B 07         [24] 1160 	mov	(_RANGER_MIN + 1),#0x07
                           000024  1161 	C$Lab_4.c$43$1$156 ==.
                                   1162 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:43: unsigned int PCA_START = 28672;
      000024 75*1C 00         [24] 1163 	mov	_PCA_START,#0x00
      000027 75*1D 70         [24] 1164 	mov	(_PCA_START + 1),#0x70
                           00002A  1165 	C$Lab_4.c$44$1$156 ==.
                                   1166 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:44: unsigned char new_heading = 0; // flag for count of compass timing
      00002A 75*1E 00         [24] 1167 	mov	_new_heading,#0x00
                           00002D  1168 	C$Lab_4.c$45$1$156 ==.
                                   1169 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:45: unsigned char new_range = 0; // flag for count of ranger timing
      00002D 75*1F 00         [24] 1170 	mov	_new_range,#0x00
                                   1171 	.area GSFINAL (CODE)
      000000 02r00r4E         [24] 1172 	ljmp	__sdcc_program_startup
                                   1173 ;--------------------------------------------------------
                                   1174 ; Home
                                   1175 ;--------------------------------------------------------
                                   1176 	.area HOME    (CODE)
                                   1177 	.area HOME    (CODE)
      00004E                       1178 __sdcc_program_startup:
      00004E 02r04rD6         [24] 1179 	ljmp	_main
                                   1180 ;	return from main will return to caller
                                   1181 ;--------------------------------------------------------
                                   1182 ; code
                                   1183 ;--------------------------------------------------------
                                   1184 	.area CSEG    (CODE)
                                   1185 ;------------------------------------------------------------
                                   1186 ;Allocation info for local variables in function 'SYSCLK_Init'
                                   1187 ;------------------------------------------------------------
                                   1188 ;i                         Allocated to registers 
                                   1189 ;------------------------------------------------------------
                           000000  1190 	G$SYSCLK_Init$0$0 ==.
                           000000  1191 	C$c8051_SDCC.h$42$0$0 ==.
                                   1192 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:42: void SYSCLK_Init(void)
                                   1193 ;	-----------------------------------------
                                   1194 ;	 function SYSCLK_Init
                                   1195 ;	-----------------------------------------
      000000                       1196 _SYSCLK_Init:
                           000007  1197 	ar7 = 0x07
                           000006  1198 	ar6 = 0x06
                           000005  1199 	ar5 = 0x05
                           000004  1200 	ar4 = 0x04
                           000003  1201 	ar3 = 0x03
                           000002  1202 	ar2 = 0x02
                           000001  1203 	ar1 = 0x01
                           000000  1204 	ar0 = 0x00
                           000000  1205 	C$c8051_SDCC.h$46$1$2 ==.
                                   1206 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:46: OSCXCN = 0x67;                      // start external oscillator with
      000000 75 B1 67         [24] 1207 	mov	_OSCXCN,#0x67
                           000003  1208 	C$c8051_SDCC.h$49$1$2 ==.
                                   1209 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:49: for (i=0; i < 256; i++);            // wait for oscillator to start
      000003 7E 00            [12] 1210 	mov	r6,#0x00
      000005 7F 01            [12] 1211 	mov	r7,#0x01
      000007                       1212 00107$:
      000007 1E               [12] 1213 	dec	r6
      000008 BE FF 01         [24] 1214 	cjne	r6,#0xFF,00121$
      00000B 1F               [12] 1215 	dec	r7
      00000C                       1216 00121$:
      00000C EE               [12] 1217 	mov	a,r6
      00000D 4F               [12] 1218 	orl	a,r7
      00000E 70 F7            [24] 1219 	jnz	00107$
                           000010  1220 	C$c8051_SDCC.h$51$1$2 ==.
                                   1221 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:51: while (!(OSCXCN & 0x80));           // Wait for crystal osc. to settle
      000010                       1222 00102$:
      000010 E5 B1            [12] 1223 	mov	a,_OSCXCN
      000012 30 E7 FB         [24] 1224 	jnb	acc.7,00102$
                           000015  1225 	C$c8051_SDCC.h$53$1$2 ==.
                                   1226 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:53: OSCICN = 0x88;                      // select external oscillator as SYSCLK
      000015 75 B2 88         [24] 1227 	mov	_OSCICN,#0x88
                           000018  1228 	C$c8051_SDCC.h$56$1$2 ==.
                           000018  1229 	XG$SYSCLK_Init$0$0 ==.
      000018 22               [24] 1230 	ret
                                   1231 ;------------------------------------------------------------
                                   1232 ;Allocation info for local variables in function 'UART0_Init'
                                   1233 ;------------------------------------------------------------
                           000019  1234 	G$UART0_Init$0$0 ==.
                           000019  1235 	C$c8051_SDCC.h$64$1$2 ==.
                                   1236 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:64: void UART0_Init(void)
                                   1237 ;	-----------------------------------------
                                   1238 ;	 function UART0_Init
                                   1239 ;	-----------------------------------------
      000019                       1240 _UART0_Init:
                           000019  1241 	C$c8051_SDCC.h$66$1$4 ==.
                                   1242 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:66: SCON0  = 0x50;                      // SCON0: mode 1, 8-bit UART, enable RX
      000019 75 98 50         [24] 1243 	mov	_SCON0,#0x50
                           00001C  1244 	C$c8051_SDCC.h$67$1$4 ==.
                                   1245 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:67: TMOD   = 0x20;                      // TMOD: timer 1, mode 2, 8-bit reload
      00001C 75 89 20         [24] 1246 	mov	_TMOD,#0x20
                           00001F  1247 	C$c8051_SDCC.h$68$1$4 ==.
                                   1248 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:68: TH1    = -(SYSCLK/BAUDRATE/16);     // set Timer1 reload value for baudrate
      00001F 75 8D DC         [24] 1249 	mov	_TH1,#0xDC
                           000022  1250 	C$c8051_SDCC.h$69$1$4 ==.
                                   1251 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:69: TR1    = 1;                         // start Timer1
      000022 D2 8E            [12] 1252 	setb	_TR1
                           000024  1253 	C$c8051_SDCC.h$70$1$4 ==.
                                   1254 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:70: CKCON |= 0x10;                      // Timer1 uses SYSCLK as time base
      000024 43 8E 10         [24] 1255 	orl	_CKCON,#0x10
                           000027  1256 	C$c8051_SDCC.h$71$1$4 ==.
                                   1257 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:71: PCON  |= 0x80;                      // SMOD00 = 1 (disable baud rate 
      000027 43 87 80         [24] 1258 	orl	_PCON,#0x80
                           00002A  1259 	C$c8051_SDCC.h$73$1$4 ==.
                                   1260 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:73: TI0    = 1;                         // Indicate TX0 ready
      00002A D2 99            [12] 1261 	setb	_TI0
                           00002C  1262 	C$c8051_SDCC.h$74$1$4 ==.
                                   1263 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:74: P0MDOUT |= 0x01;                    // Set TX0 to push/pull
      00002C 43 A4 01         [24] 1264 	orl	_P0MDOUT,#0x01
                           00002F  1265 	C$c8051_SDCC.h$75$1$4 ==.
                           00002F  1266 	XG$UART0_Init$0$0 ==.
      00002F 22               [24] 1267 	ret
                                   1268 ;------------------------------------------------------------
                                   1269 ;Allocation info for local variables in function 'Sys_Init'
                                   1270 ;------------------------------------------------------------
                           000030  1271 	G$Sys_Init$0$0 ==.
                           000030  1272 	C$c8051_SDCC.h$83$1$4 ==.
                                   1273 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:83: void Sys_Init(void)
                                   1274 ;	-----------------------------------------
                                   1275 ;	 function Sys_Init
                                   1276 ;	-----------------------------------------
      000030                       1277 _Sys_Init:
                           000030  1278 	C$c8051_SDCC.h$85$1$6 ==.
                                   1279 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:85: WDTCN = 0xde;			// disable watchdog timer
      000030 75 FF DE         [24] 1280 	mov	_WDTCN,#0xDE
                           000033  1281 	C$c8051_SDCC.h$86$1$6 ==.
                                   1282 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:86: WDTCN = 0xad;
      000033 75 FF AD         [24] 1283 	mov	_WDTCN,#0xAD
                           000036  1284 	C$c8051_SDCC.h$88$1$6 ==.
                                   1285 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:88: SYSCLK_Init();			// initialize oscillator
      000036 12r00r00         [24] 1286 	lcall	_SYSCLK_Init
                           000039  1287 	C$c8051_SDCC.h$89$1$6 ==.
                                   1288 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:89: UART0_Init();			// initialize UART0
      000039 12r00r19         [24] 1289 	lcall	_UART0_Init
                           00003C  1290 	C$c8051_SDCC.h$91$1$6 ==.
                                   1291 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:91: XBR0 |= 0x04;
      00003C 43 E1 04         [24] 1292 	orl	_XBR0,#0x04
                           00003F  1293 	C$c8051_SDCC.h$92$1$6 ==.
                                   1294 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:92: XBR2 |= 0x40;                    	// Enable crossbar and weak pull-ups
      00003F 43 E3 40         [24] 1295 	orl	_XBR2,#0x40
                           000042  1296 	C$c8051_SDCC.h$93$1$6 ==.
                           000042  1297 	XG$Sys_Init$0$0 ==.
      000042 22               [24] 1298 	ret
                                   1299 ;------------------------------------------------------------
                                   1300 ;Allocation info for local variables in function 'putchar'
                                   1301 ;------------------------------------------------------------
                                   1302 ;c                         Allocated to registers r7 
                                   1303 ;------------------------------------------------------------
                           000043  1304 	G$putchar$0$0 ==.
                           000043  1305 	C$c8051_SDCC.h$98$1$6 ==.
                                   1306 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:98: void putchar(char c)
                                   1307 ;	-----------------------------------------
                                   1308 ;	 function putchar
                                   1309 ;	-----------------------------------------
      000043                       1310 _putchar:
      000043 AF 82            [24] 1311 	mov	r7,dpl
                           000045  1312 	C$c8051_SDCC.h$100$1$8 ==.
                                   1313 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:100: while (!TI0); 
      000045                       1314 00101$:
                           000045  1315 	C$c8051_SDCC.h$101$1$8 ==.
                                   1316 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:101: TI0 = 0;
      000045 10 99 02         [24] 1317 	jbc	_TI0,00112$
      000048 80 FB            [24] 1318 	sjmp	00101$
      00004A                       1319 00112$:
                           00004A  1320 	C$c8051_SDCC.h$102$1$8 ==.
                                   1321 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:102: SBUF0 = c;
      00004A 8F 99            [24] 1322 	mov	_SBUF0,r7
                           00004C  1323 	C$c8051_SDCC.h$103$1$8 ==.
                           00004C  1324 	XG$putchar$0$0 ==.
      00004C 22               [24] 1325 	ret
                                   1326 ;------------------------------------------------------------
                                   1327 ;Allocation info for local variables in function 'getchar'
                                   1328 ;------------------------------------------------------------
                                   1329 ;c                         Allocated to registers 
                                   1330 ;------------------------------------------------------------
                           00004D  1331 	G$getchar$0$0 ==.
                           00004D  1332 	C$c8051_SDCC.h$108$1$8 ==.
                                   1333 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:108: char getchar(void)
                                   1334 ;	-----------------------------------------
                                   1335 ;	 function getchar
                                   1336 ;	-----------------------------------------
      00004D                       1337 _getchar:
                           00004D  1338 	C$c8051_SDCC.h$111$1$10 ==.
                                   1339 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:111: while (!RI0);
      00004D                       1340 00101$:
                           00004D  1341 	C$c8051_SDCC.h$112$1$10 ==.
                                   1342 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:112: RI0 = 0;
      00004D 10 98 02         [24] 1343 	jbc	_RI0,00112$
      000050 80 FB            [24] 1344 	sjmp	00101$
      000052                       1345 00112$:
                           000052  1346 	C$c8051_SDCC.h$113$1$10 ==.
                                   1347 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:113: c = SBUF0;
      000052 85 99 82         [24] 1348 	mov	dpl,_SBUF0
                           000055  1349 	C$c8051_SDCC.h$114$1$10 ==.
                                   1350 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:114: putchar(c);                          // echo to terminal
      000055 12r00r43         [24] 1351 	lcall	_putchar
                           000058  1352 	C$c8051_SDCC.h$115$1$10 ==.
                                   1353 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/c8051_SDCC.h:115: return SBUF0;
      000058 85 99 82         [24] 1354 	mov	dpl,_SBUF0
                           00005B  1355 	C$c8051_SDCC.h$116$1$10 ==.
                           00005B  1356 	XG$getchar$0$0 ==.
      00005B 22               [24] 1357 	ret
                                   1358 ;------------------------------------------------------------
                                   1359 ;Allocation info for local variables in function 'lcd_print'
                                   1360 ;------------------------------------------------------------
                                   1361 ;fmt                       Allocated to stack - _bp -5
                                   1362 ;len                       Allocated to registers r6 
                                   1363 ;i                         Allocated to registers 
                                   1364 ;ap                        Allocated to registers 
                                   1365 ;text                      Allocated with name '_lcd_print_text_1_73'
                                   1366 ;------------------------------------------------------------
                           00005C  1367 	G$lcd_print$0$0 ==.
                           00005C  1368 	C$i2c.h$81$1$10 ==.
                                   1369 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:81: void lcd_print(const char *fmt, ...)
                                   1370 ;	-----------------------------------------
                                   1371 ;	 function lcd_print
                                   1372 ;	-----------------------------------------
      00005C                       1373 _lcd_print:
      00005C C0*00            [24] 1374 	push	_bp
      00005E 85 81*00         [24] 1375 	mov	_bp,sp
                           000061  1376 	C$i2c.h$87$1$73 ==.
                                   1377 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:87: if ( strlen(fmt) <= 0 ) return;   //If there is no data to print, return
      000061 E5*00            [12] 1378 	mov	a,_bp
      000063 24 FB            [12] 1379 	add	a,#0xfb
      000065 F8               [12] 1380 	mov	r0,a
      000066 86 82            [24] 1381 	mov	dpl,@r0
      000068 08               [12] 1382 	inc	r0
      000069 86 83            [24] 1383 	mov	dph,@r0
      00006B 08               [12] 1384 	inc	r0
      00006C 86 F0            [24] 1385 	mov	b,@r0
      00006E 12r00r00         [24] 1386 	lcall	_strlen
      000071 E5 82            [12] 1387 	mov	a,dpl
      000073 85 83 F0         [24] 1388 	mov	b,dph
      000076 45 F0            [12] 1389 	orl	a,b
      000078 70 02            [24] 1390 	jnz	00102$
      00007A 80 62            [24] 1391 	sjmp	00109$
      00007C                       1392 00102$:
                           00007C  1393 	C$i2c.h$89$2$74 ==.
                                   1394 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:89: va_start(ap, fmt);
      00007C E5*00            [12] 1395 	mov	a,_bp
      00007E 24 FB            [12] 1396 	add	a,#0xFB
      000080 FF               [12] 1397 	mov	r7,a
      000081 8F*00            [24] 1398 	mov	_vsprintf_PARM_3,r7
                           000083  1399 	C$i2c.h$90$1$73 ==.
                                   1400 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:90: vsprintf(text, fmt, ap);
      000083 E5*00            [12] 1401 	mov	a,_bp
      000085 24 FB            [12] 1402 	add	a,#0xfb
      000087 F8               [12] 1403 	mov	r0,a
      000088 86*00            [24] 1404 	mov	_vsprintf_PARM_2,@r0
      00008A 08               [12] 1405 	inc	r0
      00008B 86*01            [24] 1406 	mov	(_vsprintf_PARM_2 + 1),@r0
      00008D 08               [12] 1407 	inc	r0
      00008E 86*02            [24] 1408 	mov	(_vsprintf_PARM_2 + 2),@r0
      000090 90r00r00         [24] 1409 	mov	dptr,#_lcd_print_text_1_73
      000093 75 F0 00         [24] 1410 	mov	b,#0x00
      000096 12r00r00         [24] 1411 	lcall	_vsprintf
                           000099  1412 	C$i2c.h$93$1$73 ==.
                                   1413 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:93: len = strlen(text);
      000099 90r00r00         [24] 1414 	mov	dptr,#_lcd_print_text_1_73
      00009C 75 F0 00         [24] 1415 	mov	b,#0x00
      00009F 12r00r00         [24] 1416 	lcall	_strlen
      0000A2 AE 82            [24] 1417 	mov	r6,dpl
                           0000A4  1418 	C$i2c.h$94$1$73 ==.
                                   1419 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:94: for(i=0; i<len; i++)
      0000A4 7F 00            [12] 1420 	mov	r7,#0x00
      0000A6                       1421 00107$:
      0000A6 C3               [12] 1422 	clr	c
      0000A7 EF               [12] 1423 	mov	a,r7
      0000A8 9E               [12] 1424 	subb	a,r6
      0000A9 50 1F            [24] 1425 	jnc	00105$
                           0000AB  1426 	C$i2c.h$96$2$76 ==.
                                   1427 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:96: if(text[i] == (unsigned char)'\n') text[i] = 13;
      0000AB EF               [12] 1428 	mov	a,r7
      0000AC 24r00            [12] 1429 	add	a,#_lcd_print_text_1_73
      0000AE F5 82            [12] 1430 	mov	dpl,a
      0000B0 E4               [12] 1431 	clr	a
      0000B1 34s00            [12] 1432 	addc	a,#(_lcd_print_text_1_73 >> 8)
      0000B3 F5 83            [12] 1433 	mov	dph,a
      0000B5 E0               [24] 1434 	movx	a,@dptr
      0000B6 FD               [12] 1435 	mov	r5,a
      0000B7 BD 0A 0D         [24] 1436 	cjne	r5,#0x0A,00108$
      0000BA EF               [12] 1437 	mov	a,r7
      0000BB 24r00            [12] 1438 	add	a,#_lcd_print_text_1_73
      0000BD F5 82            [12] 1439 	mov	dpl,a
      0000BF E4               [12] 1440 	clr	a
      0000C0 34s00            [12] 1441 	addc	a,#(_lcd_print_text_1_73 >> 8)
      0000C2 F5 83            [12] 1442 	mov	dph,a
      0000C4 74 0D            [12] 1443 	mov	a,#0x0D
      0000C6 F0               [24] 1444 	movx	@dptr,a
      0000C7                       1445 00108$:
                           0000C7  1446 	C$i2c.h$94$1$73 ==.
                                   1447 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:94: for(i=0; i<len; i++)
      0000C7 0F               [12] 1448 	inc	r7
      0000C8 80 DC            [24] 1449 	sjmp	00107$
      0000CA                       1450 00105$:
                           0000CA  1451 	C$i2c.h$99$1$73 ==.
                                   1452 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:99: i2c_write_data(0xC6, 0x00, text, len);
      0000CA 75*06r00         [24] 1453 	mov	_i2c_write_data_PARM_3,#_lcd_print_text_1_73
      0000CD 75*07s00         [24] 1454 	mov	(_i2c_write_data_PARM_3 + 1),#(_lcd_print_text_1_73 >> 8)
      0000D0 75*08 00         [24] 1455 	mov	(_i2c_write_data_PARM_3 + 2),#0x00
      0000D3 75*05 00         [24] 1456 	mov	_i2c_write_data_PARM_2,#0x00
      0000D6 8E*09            [24] 1457 	mov	_i2c_write_data_PARM_4,r6
      0000D8 75 82 C6         [24] 1458 	mov	dpl,#0xC6
      0000DB 12r03r72         [24] 1459 	lcall	_i2c_write_data
      0000DE                       1460 00109$:
      0000DE D0*00            [24] 1461 	pop	_bp
                           0000E0  1462 	C$i2c.h$100$1$73 ==.
                           0000E0  1463 	XG$lcd_print$0$0 ==.
      0000E0 22               [24] 1464 	ret
                                   1465 ;------------------------------------------------------------
                                   1466 ;Allocation info for local variables in function 'lcd_clear'
                                   1467 ;------------------------------------------------------------
                                   1468 ;NumBytes                  Allocated with name '_lcd_clear_NumBytes_1_77'
                                   1469 ;Cmd                       Allocated with name '_lcd_clear_Cmd_1_77'
                                   1470 ;------------------------------------------------------------
                           0000E1  1471 	G$lcd_clear$0$0 ==.
                           0000E1  1472 	C$i2c.h$103$1$73 ==.
                                   1473 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:103: void lcd_clear()
                                   1474 ;	-----------------------------------------
                                   1475 ;	 function lcd_clear
                                   1476 ;	-----------------------------------------
      0000E1                       1477 _lcd_clear:
                           0000E1  1478 	C$i2c.h$105$1$73 ==.
                                   1479 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:105: unsigned char NumBytes=0, Cmd[2];
      0000E1 75*00 00         [24] 1480 	mov	_lcd_clear_NumBytes_1_77,#0x00
                           0000E4  1481 	C$i2c.h$107$1$77 ==.
                                   1482 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:107: while(NumBytes < 64) i2c_read_data(0xC6, 0x00, &NumBytes, 1);
      0000E4                       1483 00101$:
      0000E4 74 C0            [12] 1484 	mov	a,#0x100 - 0x40
      0000E6 25*00            [12] 1485 	add	a,_lcd_clear_NumBytes_1_77
      0000E8 40 17            [24] 1486 	jc	00103$
      0000EA 75*0Br00         [24] 1487 	mov	_i2c_read_data_PARM_3,#_lcd_clear_NumBytes_1_77
      0000ED 75*0C 00         [24] 1488 	mov	(_i2c_read_data_PARM_3 + 1),#0x00
      0000F0 75*0D 40         [24] 1489 	mov	(_i2c_read_data_PARM_3 + 2),#0x40
      0000F3 75*0A 00         [24] 1490 	mov	_i2c_read_data_PARM_2,#0x00
      0000F6 75*0E 01         [24] 1491 	mov	_i2c_read_data_PARM_4,#0x01
      0000F9 75 82 C6         [24] 1492 	mov	dpl,#0xC6
      0000FC 12r03rE8         [24] 1493 	lcall	_i2c_read_data
      0000FF 80 E3            [24] 1494 	sjmp	00101$
      000101                       1495 00103$:
                           000101  1496 	C$i2c.h$109$1$77 ==.
                                   1497 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:109: Cmd[0] = 12;
      000101 75*01 0C         [24] 1498 	mov	_lcd_clear_Cmd_1_77,#0x0C
                           000104  1499 	C$i2c.h$110$1$77 ==.
                                   1500 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:110: i2c_write_data(0xC6, 0x00, Cmd, 1);
      000104 75*06r01         [24] 1501 	mov	_i2c_write_data_PARM_3,#_lcd_clear_Cmd_1_77
      000107 75*07 00         [24] 1502 	mov	(_i2c_write_data_PARM_3 + 1),#0x00
      00010A 75*08 40         [24] 1503 	mov	(_i2c_write_data_PARM_3 + 2),#0x40
      00010D 75*05 00         [24] 1504 	mov	_i2c_write_data_PARM_2,#0x00
      000110 75*09 01         [24] 1505 	mov	_i2c_write_data_PARM_4,#0x01
      000113 75 82 C6         [24] 1506 	mov	dpl,#0xC6
      000116 12r03r72         [24] 1507 	lcall	_i2c_write_data
                           000119  1508 	C$i2c.h$111$1$77 ==.
                           000119  1509 	XG$lcd_clear$0$0 ==.
      000119 22               [24] 1510 	ret
                                   1511 ;------------------------------------------------------------
                                   1512 ;Allocation info for local variables in function 'read_keypad'
                                   1513 ;------------------------------------------------------------
                                   1514 ;i                         Allocated to registers r7 
                                   1515 ;Data                      Allocated with name '_read_keypad_Data_1_78'
                                   1516 ;------------------------------------------------------------
                           00011A  1517 	G$read_keypad$0$0 ==.
                           00011A  1518 	C$i2c.h$114$1$77 ==.
                                   1519 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:114: char read_keypad()
                                   1520 ;	-----------------------------------------
                                   1521 ;	 function read_keypad
                                   1522 ;	-----------------------------------------
      00011A                       1523 _read_keypad:
                           00011A  1524 	C$i2c.h$118$1$78 ==.
                                   1525 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:118: i2c_read_data(0xC6, 0x01, Data, 2); //Read I2C data on address 192, register 1, 2 bytes of data.
      00011A 75*0Br03         [24] 1526 	mov	_i2c_read_data_PARM_3,#_read_keypad_Data_1_78
      00011D 75*0C 00         [24] 1527 	mov	(_i2c_read_data_PARM_3 + 1),#0x00
      000120 75*0D 40         [24] 1528 	mov	(_i2c_read_data_PARM_3 + 2),#0x40
      000123 75*0A 01         [24] 1529 	mov	_i2c_read_data_PARM_2,#0x01
      000126 75*0E 02         [24] 1530 	mov	_i2c_read_data_PARM_4,#0x02
      000129 75 82 C6         [24] 1531 	mov	dpl,#0xC6
      00012C 12r03rE8         [24] 1532 	lcall	_i2c_read_data
                           00012F  1533 	C$i2c.h$119$1$78 ==.
                                   1534 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:119: if(Data[0] == 0xFF) return 0;  //No response on bus, no display
      00012F 74 FF            [12] 1535 	mov	a,#0xFF
      000131 B5*03 05         [24] 1536 	cjne	a,_read_keypad_Data_1_78,00102$
      000134 75 82 00         [24] 1537 	mov	dpl,#0x00
      000137 80 5F            [24] 1538 	sjmp	00116$
      000139                       1539 00102$:
                           000139  1540 	C$i2c.h$121$1$78 ==.
                                   1541 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:121: for(i=0; i<8; i++)             //loop 8 times
      000139 7F 00            [12] 1542 	mov	r7,#0x00
      00013B 8F 06            [24] 1543 	mov	ar6,r7
      00013D                       1544 00114$:
                           00013D  1545 	C$i2c.h$123$2$79 ==.
                                   1546 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:123: if(Data[0] & (0x01 << i))  //find the ASCII value of the keypad read, if it is the current loop value
      00013D 8E F0            [24] 1547 	mov	b,r6
      00013F 05 F0            [12] 1548 	inc	b
      000141 7C 01            [12] 1549 	mov	r4,#0x01
      000143 7D 00            [12] 1550 	mov	r5,#0x00
      000145 80 06            [24] 1551 	sjmp	00145$
      000147                       1552 00144$:
      000147 EC               [12] 1553 	mov	a,r4
      000148 2C               [12] 1554 	add	a,r4
      000149 FC               [12] 1555 	mov	r4,a
      00014A ED               [12] 1556 	mov	a,r5
      00014B 33               [12] 1557 	rlc	a
      00014C FD               [12] 1558 	mov	r5,a
      00014D                       1559 00145$:
      00014D D5 F0 F7         [24] 1560 	djnz	b,00144$
      000150 AA*03            [24] 1561 	mov	r2,_read_keypad_Data_1_78
      000152 7B 00            [12] 1562 	mov	r3,#0x00
      000154 EA               [12] 1563 	mov	a,r2
      000155 52 04            [12] 1564 	anl	ar4,a
      000157 EB               [12] 1565 	mov	a,r3
      000158 52 05            [12] 1566 	anl	ar5,a
      00015A EC               [12] 1567 	mov	a,r4
      00015B 4D               [12] 1568 	orl	a,r5
      00015C 60 07            [24] 1569 	jz	00115$
                           00015E  1570 	C$i2c.h$124$2$79 ==.
                                   1571 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:124: return i+49;
      00015E 74 31            [12] 1572 	mov	a,#0x31
      000160 2F               [12] 1573 	add	a,r7
      000161 F5 82            [12] 1574 	mov	dpl,a
      000163 80 33            [24] 1575 	sjmp	00116$
      000165                       1576 00115$:
                           000165  1577 	C$i2c.h$121$1$78 ==.
                                   1578 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:121: for(i=0; i<8; i++)             //loop 8 times
      000165 0E               [12] 1579 	inc	r6
      000166 8E 07            [24] 1580 	mov	ar7,r6
      000168 BE 08 00         [24] 1581 	cjne	r6,#0x08,00147$
      00016B                       1582 00147$:
      00016B 40 D0            [24] 1583 	jc	00114$
                           00016D  1584 	C$i2c.h$127$1$78 ==.
                                   1585 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:127: if(Data[1] & 0x01) return '9'; //if the value is equal to 9 return 9.
      00016D E5*04            [12] 1586 	mov	a,(_read_keypad_Data_1_78 + 0x0001)
      00016F 30 E0 05         [24] 1587 	jnb	acc.0,00107$
      000172 75 82 39         [24] 1588 	mov	dpl,#0x39
      000175 80 21            [24] 1589 	sjmp	00116$
      000177                       1590 00107$:
                           000177  1591 	C$i2c.h$129$1$78 ==.
                                   1592 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:129: if(Data[1] & 0x02) return '*'; //if the value is equal to the star.
      000177 E5*04            [12] 1593 	mov	a,(_read_keypad_Data_1_78 + 0x0001)
      000179 30 E1 05         [24] 1594 	jnb	acc.1,00109$
      00017C 75 82 2A         [24] 1595 	mov	dpl,#0x2A
      00017F 80 17            [24] 1596 	sjmp	00116$
      000181                       1597 00109$:
                           000181  1598 	C$i2c.h$131$1$78 ==.
                                   1599 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:131: if(Data[1] & 0x04) return '0'; //if the value is equal to the 0 key
      000181 E5*04            [12] 1600 	mov	a,(_read_keypad_Data_1_78 + 0x0001)
      000183 30 E2 05         [24] 1601 	jnb	acc.2,00111$
      000186 75 82 30         [24] 1602 	mov	dpl,#0x30
      000189 80 0D            [24] 1603 	sjmp	00116$
      00018B                       1604 00111$:
                           00018B  1605 	C$i2c.h$133$1$78 ==.
                                   1606 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:133: if(Data[1] & 0x08) return '#'; //if the value is equal to the pound key
      00018B E5*04            [12] 1607 	mov	a,(_read_keypad_Data_1_78 + 0x0001)
      00018D 30 E3 05         [24] 1608 	jnb	acc.3,00113$
      000190 75 82 23         [24] 1609 	mov	dpl,#0x23
      000193 80 03            [24] 1610 	sjmp	00116$
      000195                       1611 00113$:
                           000195  1612 	C$i2c.h$135$1$78 ==.
                                   1613 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:135: return -1;                     //else return a numerical -1 (0xFF)
      000195 75 82 FF         [24] 1614 	mov	dpl,#0xFF
      000198                       1615 00116$:
                           000198  1616 	C$i2c.h$136$1$78 ==.
                           000198  1617 	XG$read_keypad$0$0 ==.
      000198 22               [24] 1618 	ret
                                   1619 ;------------------------------------------------------------
                                   1620 ;Allocation info for local variables in function 'kpd_input'
                                   1621 ;------------------------------------------------------------
                                   1622 ;mode                      Allocated to registers r7 
                                   1623 ;sum                       Allocated to registers r5 r6 
                                   1624 ;key                       Allocated to registers r3 
                                   1625 ;i                         Allocated to registers 
                                   1626 ;------------------------------------------------------------
                           000199  1627 	G$kpd_input$0$0 ==.
                           000199  1628 	C$i2c.h$148$1$78 ==.
                                   1629 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:148: unsigned int kpd_input(char mode)
                                   1630 ;	-----------------------------------------
                                   1631 ;	 function kpd_input
                                   1632 ;	-----------------------------------------
      000199                       1633 _kpd_input:
      000199 AF 82            [24] 1634 	mov	r7,dpl
                           00019B  1635 	C$i2c.h$153$1$81 ==.
                                   1636 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:153: sum = 0;
                           00019B  1637 	C$i2c.h$156$1$81 ==.
                                   1638 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:156: if(mode==0)lcd_print("\nType digits; end w/#");
      00019B E4               [12] 1639 	clr	a
      00019C FD               [12] 1640 	mov	r5,a
      00019D FE               [12] 1641 	mov	r6,a
      00019E EF               [12] 1642 	mov	a,r7
      00019F 70 1D            [24] 1643 	jnz	00102$
      0001A1 C0 06            [24] 1644 	push	ar6
      0001A3 C0 05            [24] 1645 	push	ar5
      0001A5 74r00            [12] 1646 	mov	a,#___str_0
      0001A7 C0 E0            [24] 1647 	push	acc
      0001A9 74s00            [12] 1648 	mov	a,#(___str_0 >> 8)
      0001AB C0 E0            [24] 1649 	push	acc
      0001AD 74 80            [12] 1650 	mov	a,#0x80
      0001AF C0 E0            [24] 1651 	push	acc
      0001B1 12r00r5C         [24] 1652 	lcall	_lcd_print
      0001B4 15 81            [12] 1653 	dec	sp
      0001B6 15 81            [12] 1654 	dec	sp
      0001B8 15 81            [12] 1655 	dec	sp
      0001BA D0 05            [24] 1656 	pop	ar5
      0001BC D0 06            [24] 1657 	pop	ar6
      0001BE                       1658 00102$:
                           0001BE  1659 	C$i2c.h$158$1$81 ==.
                                   1660 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:158: lcd_print("     %c%c%c%c%c",0x08,0x08,0x08,0x08,0x08);
      0001BE C0 06            [24] 1661 	push	ar6
      0001C0 C0 05            [24] 1662 	push	ar5
      0001C2 74 08            [12] 1663 	mov	a,#0x08
      0001C4 C0 E0            [24] 1664 	push	acc
      0001C6 E4               [12] 1665 	clr	a
      0001C7 C0 E0            [24] 1666 	push	acc
      0001C9 74 08            [12] 1667 	mov	a,#0x08
      0001CB C0 E0            [24] 1668 	push	acc
      0001CD E4               [12] 1669 	clr	a
      0001CE C0 E0            [24] 1670 	push	acc
      0001D0 74 08            [12] 1671 	mov	a,#0x08
      0001D2 C0 E0            [24] 1672 	push	acc
      0001D4 E4               [12] 1673 	clr	a
      0001D5 C0 E0            [24] 1674 	push	acc
      0001D7 74 08            [12] 1675 	mov	a,#0x08
      0001D9 C0 E0            [24] 1676 	push	acc
      0001DB E4               [12] 1677 	clr	a
      0001DC C0 E0            [24] 1678 	push	acc
      0001DE 74 08            [12] 1679 	mov	a,#0x08
      0001E0 C0 E0            [24] 1680 	push	acc
      0001E2 E4               [12] 1681 	clr	a
      0001E3 C0 E0            [24] 1682 	push	acc
      0001E5 74r16            [12] 1683 	mov	a,#___str_1
      0001E7 C0 E0            [24] 1684 	push	acc
      0001E9 74s00            [12] 1685 	mov	a,#(___str_1 >> 8)
      0001EB C0 E0            [24] 1686 	push	acc
      0001ED 74 80            [12] 1687 	mov	a,#0x80
      0001EF C0 E0            [24] 1688 	push	acc
      0001F1 12r00r5C         [24] 1689 	lcall	_lcd_print
      0001F4 E5 81            [12] 1690 	mov	a,sp
      0001F6 24 F3            [12] 1691 	add	a,#0xf3
      0001F8 F5 81            [12] 1692 	mov	sp,a
                           0001FA  1693 	C$i2c.h$160$1$81 ==.
                                   1694 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:160: delay_time(500000);	//Add 20ms delay before reading i2c in loop
      0001FA 90 A1 20         [24] 1695 	mov	dptr,#0xA120
      0001FD 75 F0 07         [24] 1696 	mov	b,#0x07
      000200 E4               [12] 1697 	clr	a
      000201 12r03r0D         [24] 1698 	lcall	_delay_time
      000204 D0 05            [24] 1699 	pop	ar5
      000206 D0 06            [24] 1700 	pop	ar6
                           000208  1701 	C$i2c.h$164$1$81 ==.
                                   1702 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:164: for(i=0; i<5; i++)
      000208 7F 00            [12] 1703 	mov	r7,#0x00
                           00020A  1704 	C$i2c.h$166$3$84 ==.
                                   1705 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:166: while(((key=read_keypad()) == -1) || (key == '*'))delay_time(10000);
      00020A                       1706 00104$:
      00020A C0 07            [24] 1707 	push	ar7
      00020C C0 06            [24] 1708 	push	ar6
      00020E C0 05            [24] 1709 	push	ar5
      000210 12r01r1A         [24] 1710 	lcall	_read_keypad
      000213 AC 82            [24] 1711 	mov	r4,dpl
      000215 D0 05            [24] 1712 	pop	ar5
      000217 D0 06            [24] 1713 	pop	ar6
      000219 D0 07            [24] 1714 	pop	ar7
      00021B 8C 03            [24] 1715 	mov	ar3,r4
      00021D BC FF 02         [24] 1716 	cjne	r4,#0xFF,00146$
      000220 80 03            [24] 1717 	sjmp	00105$
      000222                       1718 00146$:
      000222 BB 2A 17         [24] 1719 	cjne	r3,#0x2A,00106$
      000225                       1720 00105$:
      000225 90 27 10         [24] 1721 	mov	dptr,#0x2710
      000228 E4               [12] 1722 	clr	a
      000229 F5 F0            [12] 1723 	mov	b,a
      00022B C0 07            [24] 1724 	push	ar7
      00022D C0 06            [24] 1725 	push	ar6
      00022F C0 05            [24] 1726 	push	ar5
      000231 12r03r0D         [24] 1727 	lcall	_delay_time
      000234 D0 05            [24] 1728 	pop	ar5
      000236 D0 06            [24] 1729 	pop	ar6
      000238 D0 07            [24] 1730 	pop	ar7
      00023A 80 CE            [24] 1731 	sjmp	00104$
      00023C                       1732 00106$:
                           00023C  1733 	C$i2c.h$167$2$82 ==.
                                   1734 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:167: if(key == '#')
      00023C BB 23 2A         [24] 1735 	cjne	r3,#0x23,00114$
                           00023F  1736 	C$i2c.h$169$3$83 ==.
                                   1737 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:169: while(read_keypad() == '#')delay_time(10000);
      00023F                       1738 00107$:
      00023F C0 06            [24] 1739 	push	ar6
      000241 C0 05            [24] 1740 	push	ar5
      000243 12r01r1A         [24] 1741 	lcall	_read_keypad
      000246 AC 82            [24] 1742 	mov	r4,dpl
      000248 D0 05            [24] 1743 	pop	ar5
      00024A D0 06            [24] 1744 	pop	ar6
      00024C BC 23 13         [24] 1745 	cjne	r4,#0x23,00109$
      00024F 90 27 10         [24] 1746 	mov	dptr,#0x2710
      000252 E4               [12] 1747 	clr	a
      000253 F5 F0            [12] 1748 	mov	b,a
      000255 C0 06            [24] 1749 	push	ar6
      000257 C0 05            [24] 1750 	push	ar5
      000259 12r03r0D         [24] 1751 	lcall	_delay_time
      00025C D0 05            [24] 1752 	pop	ar5
      00025E D0 06            [24] 1753 	pop	ar6
      000260 80 DD            [24] 1754 	sjmp	00107$
      000262                       1755 00109$:
                           000262  1756 	C$i2c.h$170$3$83 ==.
                                   1757 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:170: return sum;
      000262 8D 82            [24] 1758 	mov	dpl,r5
      000264 8E 83            [24] 1759 	mov	dph,r6
      000266 02r03r0C         [24] 1760 	ljmp	00119$
      000269                       1761 00114$:
                           000269  1762 	C$i2c.h$174$3$84 ==.
                                   1763 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:174: lcd_print("%c", key);
      000269 EB               [12] 1764 	mov	a,r3
      00026A FA               [12] 1765 	mov	r2,a
      00026B 33               [12] 1766 	rlc	a
      00026C 95 E0            [12] 1767 	subb	a,acc
      00026E FC               [12] 1768 	mov	r4,a
      00026F C0 07            [24] 1769 	push	ar7
      000271 C0 06            [24] 1770 	push	ar6
      000273 C0 05            [24] 1771 	push	ar5
      000275 C0 04            [24] 1772 	push	ar4
      000277 C0 03            [24] 1773 	push	ar3
      000279 C0 02            [24] 1774 	push	ar2
      00027B C0 02            [24] 1775 	push	ar2
      00027D C0 04            [24] 1776 	push	ar4
      00027F 74r26            [12] 1777 	mov	a,#___str_2
      000281 C0 E0            [24] 1778 	push	acc
      000283 74s00            [12] 1779 	mov	a,#(___str_2 >> 8)
      000285 C0 E0            [24] 1780 	push	acc
      000287 74 80            [12] 1781 	mov	a,#0x80
      000289 C0 E0            [24] 1782 	push	acc
      00028B 12r00r5C         [24] 1783 	lcall	_lcd_print
      00028E E5 81            [12] 1784 	mov	a,sp
      000290 24 FB            [12] 1785 	add	a,#0xfb
      000292 F5 81            [12] 1786 	mov	sp,a
      000294 D0 02            [24] 1787 	pop	ar2
      000296 D0 03            [24] 1788 	pop	ar3
      000298 D0 04            [24] 1789 	pop	ar4
      00029A D0 05            [24] 1790 	pop	ar5
      00029C D0 06            [24] 1791 	pop	ar6
                           00029E  1792 	C$i2c.h$175$1$81 ==.
                                   1793 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:175: sum = sum*10 + key - '0';
      00029E 8D*00            [24] 1794 	mov	__mulint_PARM_2,r5
      0002A0 8E*01            [24] 1795 	mov	(__mulint_PARM_2 + 1),r6
      0002A2 90 00 0A         [24] 1796 	mov	dptr,#0x000A
      0002A5 C0 04            [24] 1797 	push	ar4
      0002A7 C0 03            [24] 1798 	push	ar3
      0002A9 C0 02            [24] 1799 	push	ar2
      0002AB 12r00r00         [24] 1800 	lcall	__mulint
      0002AE A8 82            [24] 1801 	mov	r0,dpl
      0002B0 A9 83            [24] 1802 	mov	r1,dph
      0002B2 D0 02            [24] 1803 	pop	ar2
      0002B4 D0 03            [24] 1804 	pop	ar3
      0002B6 D0 04            [24] 1805 	pop	ar4
      0002B8 D0 07            [24] 1806 	pop	ar7
      0002BA EA               [12] 1807 	mov	a,r2
      0002BB 28               [12] 1808 	add	a,r0
      0002BC F8               [12] 1809 	mov	r0,a
      0002BD EC               [12] 1810 	mov	a,r4
      0002BE 39               [12] 1811 	addc	a,r1
      0002BF F9               [12] 1812 	mov	r1,a
      0002C0 E8               [12] 1813 	mov	a,r0
      0002C1 24 D0            [12] 1814 	add	a,#0xD0
      0002C3 FD               [12] 1815 	mov	r5,a
      0002C4 E9               [12] 1816 	mov	a,r1
      0002C5 34 FF            [12] 1817 	addc	a,#0xFF
      0002C7 FE               [12] 1818 	mov	r6,a
                           0002C8  1819 	C$i2c.h$176$3$84 ==.
                                   1820 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:176: while(read_keypad() == key)delay_time(10000); //wait for key to be released
      0002C8                       1821 00110$:
      0002C8 C0 07            [24] 1822 	push	ar7
      0002CA C0 06            [24] 1823 	push	ar6
      0002CC C0 05            [24] 1824 	push	ar5
      0002CE C0 03            [24] 1825 	push	ar3
      0002D0 12r01r1A         [24] 1826 	lcall	_read_keypad
      0002D3 AC 82            [24] 1827 	mov	r4,dpl
      0002D5 D0 03            [24] 1828 	pop	ar3
      0002D7 D0 05            [24] 1829 	pop	ar5
      0002D9 D0 06            [24] 1830 	pop	ar6
      0002DB D0 07            [24] 1831 	pop	ar7
      0002DD EC               [12] 1832 	mov	a,r4
      0002DE B5 03 1B         [24] 1833 	cjne	a,ar3,00118$
      0002E1 90 27 10         [24] 1834 	mov	dptr,#0x2710
      0002E4 E4               [12] 1835 	clr	a
      0002E5 F5 F0            [12] 1836 	mov	b,a
      0002E7 C0 07            [24] 1837 	push	ar7
      0002E9 C0 06            [24] 1838 	push	ar6
      0002EB C0 05            [24] 1839 	push	ar5
      0002ED C0 03            [24] 1840 	push	ar3
      0002EF 12r03r0D         [24] 1841 	lcall	_delay_time
      0002F2 D0 03            [24] 1842 	pop	ar3
      0002F4 D0 05            [24] 1843 	pop	ar5
      0002F6 D0 06            [24] 1844 	pop	ar6
      0002F8 D0 07            [24] 1845 	pop	ar7
      0002FA 80 CC            [24] 1846 	sjmp	00110$
      0002FC                       1847 00118$:
                           0002FC  1848 	C$i2c.h$164$1$81 ==.
                                   1849 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:164: for(i=0; i<5; i++)
      0002FC 0F               [12] 1850 	inc	r7
      0002FD C3               [12] 1851 	clr	c
      0002FE EF               [12] 1852 	mov	a,r7
      0002FF 64 80            [12] 1853 	xrl	a,#0x80
      000301 94 85            [12] 1854 	subb	a,#0x85
      000303 50 03            [24] 1855 	jnc	00155$
      000305 02r02r0A         [24] 1856 	ljmp	00104$
      000308                       1857 00155$:
                           000308  1858 	C$i2c.h$179$1$81 ==.
                                   1859 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:179: return sum;
      000308 8D 82            [24] 1860 	mov	dpl,r5
      00030A 8E 83            [24] 1861 	mov	dph,r6
      00030C                       1862 00119$:
                           00030C  1863 	C$i2c.h$180$1$81 ==.
                           00030C  1864 	XG$kpd_input$0$0 ==.
      00030C 22               [24] 1865 	ret
                                   1866 ;------------------------------------------------------------
                                   1867 ;Allocation info for local variables in function 'delay_time'
                                   1868 ;------------------------------------------------------------
                                   1869 ;time_end                  Allocated to registers r4 r5 r6 r7 
                                   1870 ;index                     Allocated to registers 
                                   1871 ;------------------------------------------------------------
                           00030D  1872 	G$delay_time$0$0 ==.
                           00030D  1873 	C$i2c.h$189$1$81 ==.
                                   1874 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:189: void delay_time (unsigned long time_end)
                                   1875 ;	-----------------------------------------
                                   1876 ;	 function delay_time
                                   1877 ;	-----------------------------------------
      00030D                       1878 _delay_time:
      00030D AC 82            [24] 1879 	mov	r4,dpl
      00030F AD 83            [24] 1880 	mov	r5,dph
      000311 AE F0            [24] 1881 	mov	r6,b
      000313 FF               [12] 1882 	mov	r7,a
                           000314  1883 	C$i2c.h$192$1$86 ==.
                                   1884 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:192: for (index = 0; index < time_end; index++); //for loop delay
      000314 78 00            [12] 1885 	mov	r0,#0x00
      000316 79 00            [12] 1886 	mov	r1,#0x00
      000318 7A 00            [12] 1887 	mov	r2,#0x00
      00031A 7B 00            [12] 1888 	mov	r3,#0x00
      00031C                       1889 00103$:
      00031C C3               [12] 1890 	clr	c
      00031D E8               [12] 1891 	mov	a,r0
      00031E 9C               [12] 1892 	subb	a,r4
      00031F E9               [12] 1893 	mov	a,r1
      000320 9D               [12] 1894 	subb	a,r5
      000321 EA               [12] 1895 	mov	a,r2
      000322 9E               [12] 1896 	subb	a,r6
      000323 EB               [12] 1897 	mov	a,r3
      000324 9F               [12] 1898 	subb	a,r7
      000325 50 0F            [24] 1899 	jnc	00105$
      000327 08               [12] 1900 	inc	r0
      000328 B8 00 09         [24] 1901 	cjne	r0,#0x00,00115$
      00032B 09               [12] 1902 	inc	r1
      00032C B9 00 05         [24] 1903 	cjne	r1,#0x00,00115$
      00032F 0A               [12] 1904 	inc	r2
      000330 BA 00 E9         [24] 1905 	cjne	r2,#0x00,00103$
      000333 0B               [12] 1906 	inc	r3
      000334                       1907 00115$:
      000334 80 E6            [24] 1908 	sjmp	00103$
      000336                       1909 00105$:
                           000336  1910 	C$i2c.h$193$1$86 ==.
                           000336  1911 	XG$delay_time$0$0 ==.
      000336 22               [24] 1912 	ret
                                   1913 ;------------------------------------------------------------
                                   1914 ;Allocation info for local variables in function 'i2c_start'
                                   1915 ;------------------------------------------------------------
                           000337  1916 	G$i2c_start$0$0 ==.
                           000337  1917 	C$i2c.h$196$1$86 ==.
                                   1918 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:196: void i2c_start(void)
                                   1919 ;	-----------------------------------------
                                   1920 ;	 function i2c_start
                                   1921 ;	-----------------------------------------
      000337                       1922 _i2c_start:
                           000337  1923 	C$i2c.h$198$1$88 ==.
                                   1924 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:198: while(BUSY);              //Wait until SMBus0 is free
      000337                       1925 00101$:
      000337 20 C7 FD         [24] 1926 	jb	_BUSY,00101$
                           00033A  1927 	C$i2c.h$199$1$88 ==.
                                   1928 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:199: STA = 1;                  //Set Start Bit
      00033A D2 C5            [12] 1929 	setb	_STA
                           00033C  1930 	C$i2c.h$200$1$88 ==.
                                   1931 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:200: while(!SI);               //Wait until start sent
      00033C                       1932 00104$:
      00033C 30 C3 FD         [24] 1933 	jnb	_SI,00104$
                           00033F  1934 	C$i2c.h$201$1$88 ==.
                                   1935 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:201: STA = 0;                  //Clear start bit
      00033F C2 C5            [12] 1936 	clr	_STA
                           000341  1937 	C$i2c.h$202$1$88 ==.
                                   1938 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:202: SI = 0;                   //Clear SI
      000341 C2 C3            [12] 1939 	clr	_SI
                           000343  1940 	C$i2c.h$203$1$88 ==.
                           000343  1941 	XG$i2c_start$0$0 ==.
      000343 22               [24] 1942 	ret
                                   1943 ;------------------------------------------------------------
                                   1944 ;Allocation info for local variables in function 'i2c_write'
                                   1945 ;------------------------------------------------------------
                                   1946 ;output_data               Allocated to registers 
                                   1947 ;------------------------------------------------------------
                           000344  1948 	G$i2c_write$0$0 ==.
                           000344  1949 	C$i2c.h$206$1$88 ==.
                                   1950 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:206: void i2c_write(unsigned char output_data)
                                   1951 ;	-----------------------------------------
                                   1952 ;	 function i2c_write
                                   1953 ;	-----------------------------------------
      000344                       1954 _i2c_write:
      000344 85 82 C2         [24] 1955 	mov	_SMB0DAT,dpl
                           000347  1956 	C$i2c.h$209$1$90 ==.
                                   1957 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:209: while(!SI);               //Wait until send is complete
      000347                       1958 00101$:
                           000347  1959 	C$i2c.h$210$1$90 ==.
                                   1960 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:210: SI = 0;                   //Clear SI
      000347 10 C3 02         [24] 1961 	jbc	_SI,00112$
      00034A 80 FB            [24] 1962 	sjmp	00101$
      00034C                       1963 00112$:
                           00034C  1964 	C$i2c.h$211$1$90 ==.
                           00034C  1965 	XG$i2c_write$0$0 ==.
      00034C 22               [24] 1966 	ret
                                   1967 ;------------------------------------------------------------
                                   1968 ;Allocation info for local variables in function 'i2c_write_and_stop'
                                   1969 ;------------------------------------------------------------
                                   1970 ;output_data               Allocated to registers 
                                   1971 ;------------------------------------------------------------
                           00034D  1972 	G$i2c_write_and_stop$0$0 ==.
                           00034D  1973 	C$i2c.h$214$1$90 ==.
                                   1974 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:214: void i2c_write_and_stop(unsigned char output_data)
                                   1975 ;	-----------------------------------------
                                   1976 ;	 function i2c_write_and_stop
                                   1977 ;	-----------------------------------------
      00034D                       1978 _i2c_write_and_stop:
      00034D 85 82 C2         [24] 1979 	mov	_SMB0DAT,dpl
                           000350  1980 	C$i2c.h$217$1$92 ==.
                                   1981 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:217: STO = 1;                  //Set stop bit
      000350 D2 C4            [12] 1982 	setb	_STO
                           000352  1983 	C$i2c.h$218$1$92 ==.
                                   1984 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:218: while(!SI);               //Wait until send is complete
      000352                       1985 00101$:
                           000352  1986 	C$i2c.h$219$1$92 ==.
                                   1987 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:219: SI = 0;                   //clear SI
      000352 10 C3 02         [24] 1988 	jbc	_SI,00112$
      000355 80 FB            [24] 1989 	sjmp	00101$
      000357                       1990 00112$:
                           000357  1991 	C$i2c.h$220$1$92 ==.
                           000357  1992 	XG$i2c_write_and_stop$0$0 ==.
      000357 22               [24] 1993 	ret
                                   1994 ;------------------------------------------------------------
                                   1995 ;Allocation info for local variables in function 'i2c_read'
                                   1996 ;------------------------------------------------------------
                                   1997 ;input_data                Allocated to registers 
                                   1998 ;------------------------------------------------------------
                           000358  1999 	G$i2c_read$0$0 ==.
                           000358  2000 	C$i2c.h$223$1$92 ==.
                                   2001 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:223: unsigned char i2c_read(void)
                                   2002 ;	-----------------------------------------
                                   2003 ;	 function i2c_read
                                   2004 ;	-----------------------------------------
      000358                       2005 _i2c_read:
                           000358  2006 	C$i2c.h$226$1$94 ==.
                                   2007 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:226: while(!SI);                //Wait until we have data to read
      000358                       2008 00101$:
      000358 30 C3 FD         [24] 2009 	jnb	_SI,00101$
                           00035B  2010 	C$i2c.h$227$1$94 ==.
                                   2011 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:227: input_data = SMB0DAT;      //Read the data
      00035B 85 C2 82         [24] 2012 	mov	dpl,_SMB0DAT
                           00035E  2013 	C$i2c.h$228$1$94 ==.
                                   2014 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:228: SI = 0;                    //Clear SI
      00035E C2 C3            [12] 2015 	clr	_SI
                           000360  2016 	C$i2c.h$229$1$94 ==.
                                   2017 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:229: return input_data;         //Return the read data
                           000360  2018 	C$i2c.h$230$1$94 ==.
                           000360  2019 	XG$i2c_read$0$0 ==.
      000360 22               [24] 2020 	ret
                                   2021 ;------------------------------------------------------------
                                   2022 ;Allocation info for local variables in function 'i2c_read_and_stop'
                                   2023 ;------------------------------------------------------------
                                   2024 ;input_data                Allocated to registers r7 
                                   2025 ;------------------------------------------------------------
                           000361  2026 	G$i2c_read_and_stop$0$0 ==.
                           000361  2027 	C$i2c.h$233$1$94 ==.
                                   2028 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:233: unsigned char i2c_read_and_stop(void)
                                   2029 ;	-----------------------------------------
                                   2030 ;	 function i2c_read_and_stop
                                   2031 ;	-----------------------------------------
      000361                       2032 _i2c_read_and_stop:
                           000361  2033 	C$i2c.h$236$1$96 ==.
                                   2034 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:236: while(!SI);                //Wait until we have data to read
      000361                       2035 00101$:
      000361 30 C3 FD         [24] 2036 	jnb	_SI,00101$
                           000364  2037 	C$i2c.h$237$1$96 ==.
                                   2038 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:237: input_data = SMB0DAT;      //Read the data
      000364 AF C2            [24] 2039 	mov	r7,_SMB0DAT
                           000366  2040 	C$i2c.h$238$1$96 ==.
                                   2041 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:238: SI = 0;                    //Clear SI
      000366 C2 C3            [12] 2042 	clr	_SI
                           000368  2043 	C$i2c.h$239$1$96 ==.
                                   2044 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:239: STO = 1;                   //Set stop bit
      000368 D2 C4            [12] 2045 	setb	_STO
                           00036A  2046 	C$i2c.h$240$1$96 ==.
                                   2047 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:240: while(!SI);                //Wait for stop
      00036A                       2048 00104$:
                           00036A  2049 	C$i2c.h$241$1$96 ==.
                                   2050 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:241: SI = 0;
      00036A 10 C3 02         [24] 2051 	jbc	_SI,00122$
      00036D 80 FB            [24] 2052 	sjmp	00104$
      00036F                       2053 00122$:
                           00036F  2054 	C$i2c.h$242$1$96 ==.
                                   2055 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:242: return input_data;         //Return the read data
      00036F 8F 82            [24] 2056 	mov	dpl,r7
                           000371  2057 	C$i2c.h$243$1$96 ==.
                           000371  2058 	XG$i2c_read_and_stop$0$0 ==.
      000371 22               [24] 2059 	ret
                                   2060 ;------------------------------------------------------------
                                   2061 ;Allocation info for local variables in function 'i2c_write_data'
                                   2062 ;------------------------------------------------------------
                                   2063 ;start_reg                 Allocated with name '_i2c_write_data_PARM_2'
                                   2064 ;buffer                    Allocated with name '_i2c_write_data_PARM_3'
                                   2065 ;num_bytes                 Allocated with name '_i2c_write_data_PARM_4'
                                   2066 ;addr                      Allocated to registers r7 
                                   2067 ;i                         Allocated to registers 
                                   2068 ;------------------------------------------------------------
                           000372  2069 	G$i2c_write_data$0$0 ==.
                           000372  2070 	C$i2c.h$246$1$96 ==.
                                   2071 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:246: void i2c_write_data(unsigned char addr, unsigned char start_reg, unsigned char *buffer, unsigned char num_bytes)
                                   2072 ;	-----------------------------------------
                                   2073 ;	 function i2c_write_data
                                   2074 ;	-----------------------------------------
      000372                       2075 _i2c_write_data:
      000372 AF 82            [24] 2076 	mov	r7,dpl
                           000374  2077 	C$i2c.h$250$1$98 ==.
                                   2078 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:250: i2c_start();               //initiate I2C transfer
      000374 C0 07            [24] 2079 	push	ar7
      000376 12r03r37         [24] 2080 	lcall	_i2c_start
      000379 D0 07            [24] 2081 	pop	ar7
                           00037B  2082 	C$i2c.h$251$1$98 ==.
                                   2083 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:251: i2c_write(addr & ~0x01);   //write the desired address to the bus
      00037B 74 FE            [12] 2084 	mov	a,#0xFE
      00037D 5F               [12] 2085 	anl	a,r7
      00037E F5 82            [12] 2086 	mov	dpl,a
      000380 12r03r44         [24] 2087 	lcall	_i2c_write
                           000383  2088 	C$i2c.h$252$1$98 ==.
                                   2089 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:252: i2c_write(start_reg);      //write the start register to the bus
      000383 85*05 82         [24] 2090 	mov	dpl,_i2c_write_data_PARM_2
      000386 12r03r44         [24] 2091 	lcall	_i2c_write
                           000389  2092 	C$i2c.h$253$1$98 ==.
                                   2093 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:253: for(i=0; i<num_bytes-1; i++) //write the data to the register(s)
      000389 7F 00            [12] 2094 	mov	r7,#0x00
      00038B                       2095 00103$:
      00038B AD*09            [24] 2096 	mov	r5,_i2c_write_data_PARM_4
      00038D 7E 00            [12] 2097 	mov	r6,#0x00
      00038F 1D               [12] 2098 	dec	r5
      000390 BD FF 01         [24] 2099 	cjne	r5,#0xFF,00114$
      000393 1E               [12] 2100 	dec	r6
      000394                       2101 00114$:
      000394 8F 03            [24] 2102 	mov	ar3,r7
      000396 7C 00            [12] 2103 	mov	r4,#0x00
      000398 C3               [12] 2104 	clr	c
      000399 EB               [12] 2105 	mov	a,r3
      00039A 9D               [12] 2106 	subb	a,r5
      00039B EC               [12] 2107 	mov	a,r4
      00039C 64 80            [12] 2108 	xrl	a,#0x80
      00039E 8E F0            [24] 2109 	mov	b,r6
      0003A0 63 F0 80         [24] 2110 	xrl	b,#0x80
      0003A3 95 F0            [12] 2111 	subb	a,b
      0003A5 50 1F            [24] 2112 	jnc	00101$
                           0003A7  2113 	C$i2c.h$254$1$98 ==.
                                   2114 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:254: i2c_write(buffer[i]);
      0003A7 EF               [12] 2115 	mov	a,r7
      0003A8 25*06            [12] 2116 	add	a,_i2c_write_data_PARM_3
      0003AA FC               [12] 2117 	mov	r4,a
      0003AB E4               [12] 2118 	clr	a
      0003AC 35*07            [12] 2119 	addc	a,(_i2c_write_data_PARM_3 + 1)
      0003AE FD               [12] 2120 	mov	r5,a
      0003AF AE*08            [24] 2121 	mov	r6,(_i2c_write_data_PARM_3 + 2)
      0003B1 8C 82            [24] 2122 	mov	dpl,r4
      0003B3 8D 83            [24] 2123 	mov	dph,r5
      0003B5 8E F0            [24] 2124 	mov	b,r6
      0003B7 12r00r00         [24] 2125 	lcall	__gptrget
      0003BA F5 82            [12] 2126 	mov	dpl,a
      0003BC C0 07            [24] 2127 	push	ar7
      0003BE 12r03r44         [24] 2128 	lcall	_i2c_write
      0003C1 D0 07            [24] 2129 	pop	ar7
                           0003C3  2130 	C$i2c.h$253$1$98 ==.
                                   2131 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:253: for(i=0; i<num_bytes-1; i++) //write the data to the register(s)
      0003C3 0F               [12] 2132 	inc	r7
      0003C4 80 C5            [24] 2133 	sjmp	00103$
      0003C6                       2134 00101$:
                           0003C6  2135 	C$i2c.h$255$1$98 ==.
                                   2136 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:255: i2c_write_and_stop(buffer[num_bytes-1]); //Stop transfer
      0003C6 AE*09            [24] 2137 	mov	r6,_i2c_write_data_PARM_4
      0003C8 7F 00            [12] 2138 	mov	r7,#0x00
      0003CA 1E               [12] 2139 	dec	r6
      0003CB BE FF 01         [24] 2140 	cjne	r6,#0xFF,00116$
      0003CE 1F               [12] 2141 	dec	r7
      0003CF                       2142 00116$:
      0003CF EE               [12] 2143 	mov	a,r6
      0003D0 25*06            [12] 2144 	add	a,_i2c_write_data_PARM_3
      0003D2 FE               [12] 2145 	mov	r6,a
      0003D3 EF               [12] 2146 	mov	a,r7
      0003D4 35*07            [12] 2147 	addc	a,(_i2c_write_data_PARM_3 + 1)
      0003D6 FF               [12] 2148 	mov	r7,a
      0003D7 AD*08            [24] 2149 	mov	r5,(_i2c_write_data_PARM_3 + 2)
      0003D9 8E 82            [24] 2150 	mov	dpl,r6
      0003DB 8F 83            [24] 2151 	mov	dph,r7
      0003DD 8D F0            [24] 2152 	mov	b,r5
      0003DF 12r00r00         [24] 2153 	lcall	__gptrget
      0003E2 F5 82            [12] 2154 	mov	dpl,a
      0003E4 12r03r4D         [24] 2155 	lcall	_i2c_write_and_stop
                           0003E7  2156 	C$i2c.h$256$1$98 ==.
                           0003E7  2157 	XG$i2c_write_data$0$0 ==.
      0003E7 22               [24] 2158 	ret
                                   2159 ;------------------------------------------------------------
                                   2160 ;Allocation info for local variables in function 'i2c_read_data'
                                   2161 ;------------------------------------------------------------
                                   2162 ;start_reg                 Allocated with name '_i2c_read_data_PARM_2'
                                   2163 ;buffer                    Allocated with name '_i2c_read_data_PARM_3'
                                   2164 ;num_bytes                 Allocated with name '_i2c_read_data_PARM_4'
                                   2165 ;addr                      Allocated to registers r7 
                                   2166 ;j                         Allocated to registers 
                                   2167 ;------------------------------------------------------------
                           0003E8  2168 	G$i2c_read_data$0$0 ==.
                           0003E8  2169 	C$i2c.h$259$1$98 ==.
                                   2170 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:259: void i2c_read_data(unsigned char addr, unsigned char start_reg, unsigned char *buffer, unsigned char num_bytes)
                                   2171 ;	-----------------------------------------
                                   2172 ;	 function i2c_read_data
                                   2173 ;	-----------------------------------------
      0003E8                       2174 _i2c_read_data:
      0003E8 AF 82            [24] 2175 	mov	r7,dpl
                           0003EA  2176 	C$i2c.h$262$1$100 ==.
                                   2177 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:262: i2c_start();               //Start I2C transfer
      0003EA C0 07            [24] 2178 	push	ar7
      0003EC 12r03r37         [24] 2179 	lcall	_i2c_start
      0003EF D0 07            [24] 2180 	pop	ar7
                           0003F1  2181 	C$i2c.h$263$1$100 ==.
                                   2182 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:263: i2c_write(addr & ~0x01);   //Write address of device that will be written to, send 0
      0003F1 8F 06            [24] 2183 	mov	ar6,r7
      0003F3 74 FE            [12] 2184 	mov	a,#0xFE
      0003F5 5E               [12] 2185 	anl	a,r6
      0003F6 F5 82            [12] 2186 	mov	dpl,a
      0003F8 C0 07            [24] 2187 	push	ar7
      0003FA 12r03r44         [24] 2188 	lcall	_i2c_write
                           0003FD  2189 	C$i2c.h$264$1$100 ==.
                                   2190 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:264: i2c_write_and_stop(start_reg); //Write & stop the 1st register to be read
      0003FD 85*0A 82         [24] 2191 	mov	dpl,_i2c_read_data_PARM_2
      000400 12r03r4D         [24] 2192 	lcall	_i2c_write_and_stop
                           000403  2193 	C$i2c.h$265$1$100 ==.
                                   2194 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:265: i2c_start();               //Start I2C transfer
      000403 12r03r37         [24] 2195 	lcall	_i2c_start
      000406 D0 07            [24] 2196 	pop	ar7
                           000408  2197 	C$i2c.h$266$1$100 ==.
                                   2198 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:266: i2c_write(addr | 0x01);    //Write address again, this time indicating a read operation
      000408 74 01            [12] 2199 	mov	a,#0x01
      00040A 4F               [12] 2200 	orl	a,r7
      00040B F5 82            [12] 2201 	mov	dpl,a
      00040D 12r03r44         [24] 2202 	lcall	_i2c_write
                           000410  2203 	C$i2c.h$267$1$100 ==.
                                   2204 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:267: for(j = 0; j < num_bytes - 1; j++)
      000410 7F 00            [12] 2205 	mov	r7,#0x00
      000412                       2206 00103$:
      000412 AD*0E            [24] 2207 	mov	r5,_i2c_read_data_PARM_4
      000414 7E 00            [12] 2208 	mov	r6,#0x00
      000416 1D               [12] 2209 	dec	r5
      000417 BD FF 01         [24] 2210 	cjne	r5,#0xFF,00114$
      00041A 1E               [12] 2211 	dec	r6
      00041B                       2212 00114$:
      00041B 8F 03            [24] 2213 	mov	ar3,r7
      00041D 7C 00            [12] 2214 	mov	r4,#0x00
      00041F C3               [12] 2215 	clr	c
      000420 EB               [12] 2216 	mov	a,r3
      000421 9D               [12] 2217 	subb	a,r5
      000422 EC               [12] 2218 	mov	a,r4
      000423 64 80            [12] 2219 	xrl	a,#0x80
      000425 8E F0            [24] 2220 	mov	b,r6
      000427 63 F0 80         [24] 2221 	xrl	b,#0x80
      00042A 95 F0            [12] 2222 	subb	a,b
      00042C 50 2E            [24] 2223 	jnc	00101$
                           00042E  2224 	C$i2c.h$269$2$101 ==.
                                   2225 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:269: AA = 1;                //Set acknowledge bit
      00042E D2 C2            [12] 2226 	setb	_AA
                           000430  2227 	C$i2c.h$270$2$101 ==.
                                   2228 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:270: buffer[j] = i2c_read();//Read data, save it in buffer
      000430 EF               [12] 2229 	mov	a,r7
      000431 25*0B            [12] 2230 	add	a,_i2c_read_data_PARM_3
      000433 FC               [12] 2231 	mov	r4,a
      000434 E4               [12] 2232 	clr	a
      000435 35*0C            [12] 2233 	addc	a,(_i2c_read_data_PARM_3 + 1)
      000437 FD               [12] 2234 	mov	r5,a
      000438 AE*0D            [24] 2235 	mov	r6,(_i2c_read_data_PARM_3 + 2)
      00043A C0 07            [24] 2236 	push	ar7
      00043C C0 06            [24] 2237 	push	ar6
      00043E C0 05            [24] 2238 	push	ar5
      000440 C0 04            [24] 2239 	push	ar4
      000442 12r03r58         [24] 2240 	lcall	_i2c_read
      000445 AB 82            [24] 2241 	mov	r3,dpl
      000447 D0 04            [24] 2242 	pop	ar4
      000449 D0 05            [24] 2243 	pop	ar5
      00044B D0 06            [24] 2244 	pop	ar6
      00044D D0 07            [24] 2245 	pop	ar7
      00044F 8C 82            [24] 2246 	mov	dpl,r4
      000451 8D 83            [24] 2247 	mov	dph,r5
      000453 8E F0            [24] 2248 	mov	b,r6
      000455 EB               [12] 2249 	mov	a,r3
      000456 12r00r00         [24] 2250 	lcall	__gptrput
                           000459  2251 	C$i2c.h$267$1$100 ==.
                                   2252 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:267: for(j = 0; j < num_bytes - 1; j++)
      000459 0F               [12] 2253 	inc	r7
      00045A 80 B6            [24] 2254 	sjmp	00103$
      00045C                       2255 00101$:
                           00045C  2256 	C$i2c.h$272$1$100 ==.
                                   2257 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:272: AA = 0;
      00045C C2 C2            [12] 2258 	clr	_AA
                           00045E  2259 	C$i2c.h$273$1$100 ==.
                                   2260 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:273: buffer[num_bytes - 1] = i2c_read_and_stop(); //Read the last byte and stop, save it in the buffer
      00045E AE*0E            [24] 2261 	mov	r6,_i2c_read_data_PARM_4
      000460 7F 00            [12] 2262 	mov	r7,#0x00
      000462 1E               [12] 2263 	dec	r6
      000463 BE FF 01         [24] 2264 	cjne	r6,#0xFF,00116$
      000466 1F               [12] 2265 	dec	r7
      000467                       2266 00116$:
      000467 EE               [12] 2267 	mov	a,r6
      000468 25*0B            [12] 2268 	add	a,_i2c_read_data_PARM_3
      00046A FE               [12] 2269 	mov	r6,a
      00046B EF               [12] 2270 	mov	a,r7
      00046C 35*0C            [12] 2271 	addc	a,(_i2c_read_data_PARM_3 + 1)
      00046E FF               [12] 2272 	mov	r7,a
      00046F AD*0D            [24] 2273 	mov	r5,(_i2c_read_data_PARM_3 + 2)
      000471 C0 07            [24] 2274 	push	ar7
      000473 C0 06            [24] 2275 	push	ar6
      000475 C0 05            [24] 2276 	push	ar5
      000477 12r03r61         [24] 2277 	lcall	_i2c_read_and_stop
      00047A AC 82            [24] 2278 	mov	r4,dpl
      00047C D0 05            [24] 2279 	pop	ar5
      00047E D0 06            [24] 2280 	pop	ar6
      000480 D0 07            [24] 2281 	pop	ar7
      000482 8E 82            [24] 2282 	mov	dpl,r6
      000484 8F 83            [24] 2283 	mov	dph,r7
      000486 8D F0            [24] 2284 	mov	b,r5
      000488 EC               [12] 2285 	mov	a,r4
      000489 12r00r00         [24] 2286 	lcall	__gptrput
                           00048C  2287 	C$i2c.h$274$1$100 ==.
                           00048C  2288 	XG$i2c_read_data$0$0 ==.
      00048C 22               [24] 2289 	ret
                                   2290 ;------------------------------------------------------------
                                   2291 ;Allocation info for local variables in function 'Accel_Init'
                                   2292 ;------------------------------------------------------------
                                   2293 ;Data2                     Allocated with name '_Accel_Init_Data2_1_103'
                                   2294 ;------------------------------------------------------------
                           00048D  2295 	G$Accel_Init$0$0 ==.
                           00048D  2296 	C$i2c.h$283$1$100 ==.
                                   2297 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:283: void Accel_Init(void)
                                   2298 ;	-----------------------------------------
                                   2299 ;	 function Accel_Init
                                   2300 ;	-----------------------------------------
      00048D                       2301 _Accel_Init:
                           00048D  2302 	C$i2c.h$287$1$103 ==.
                                   2303 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:287: Data2[0]=0x23;	//normal power mode, 50Hz ODR, y & x axes enabled
      00048D 75*0F 23         [24] 2304 	mov	_Accel_Init_Data2_1_103,#0x23
                           000490  2305 	C$i2c.h$289$1$103 ==.
                                   2306 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:289: i2c_write_data(addr_accel, 0x20, Data2, 1);
      000490 75*06r0F         [24] 2307 	mov	_i2c_write_data_PARM_3,#_Accel_Init_Data2_1_103
      000493 75*07 00         [24] 2308 	mov	(_i2c_write_data_PARM_3 + 1),#0x00
      000496 75*08 40         [24] 2309 	mov	(_i2c_write_data_PARM_3 + 2),#0x40
      000499 75*05 20         [24] 2310 	mov	_i2c_write_data_PARM_2,#0x20
      00049C 75*09 01         [24] 2311 	mov	_i2c_write_data_PARM_4,#0x01
      00049F 75 82 30         [24] 2312 	mov	dpl,#0x30
      0004A2 12r03r72         [24] 2313 	lcall	_i2c_write_data
                           0004A5  2314 	C$i2c.h$290$1$103 ==.
                                   2315 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:290: Data2[0]=0x00;	//Default - no filtering
      0004A5 75*0F 00         [24] 2316 	mov	_Accel_Init_Data2_1_103,#0x00
                           0004A8  2317 	C$i2c.h$292$1$103 ==.
                                   2318 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:292: i2c_write_data(addr_accel, 0x21, Data2, 1);
      0004A8 75*06r0F         [24] 2319 	mov	_i2c_write_data_PARM_3,#_Accel_Init_Data2_1_103
      0004AB 75*07 00         [24] 2320 	mov	(_i2c_write_data_PARM_3 + 1),#0x00
      0004AE 75*08 40         [24] 2321 	mov	(_i2c_write_data_PARM_3 + 2),#0x40
      0004B1 75*05 21         [24] 2322 	mov	_i2c_write_data_PARM_2,#0x21
      0004B4 75*09 01         [24] 2323 	mov	_i2c_write_data_PARM_4,#0x01
      0004B7 75 82 30         [24] 2324 	mov	dpl,#0x30
      0004BA 12r03r72         [24] 2325 	lcall	_i2c_write_data
                           0004BD  2326 	C$i2c.h$293$1$103 ==.
                                   2327 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:293: Data2[0]=0x00;	//default - no interrupts enabled
      0004BD 75*0F 00         [24] 2328 	mov	_Accel_Init_Data2_1_103,#0x00
                           0004C0  2329 	C$i2c.h$294$1$103 ==.
                                   2330 ;	C:/Program Files (x86)/SDCC/bin/../include/mcs51/i2c.h:294: i2c_write_data(addr_accel, 0x22, Data2, 1);
      0004C0 75*06r0F         [24] 2331 	mov	_i2c_write_data_PARM_3,#_Accel_Init_Data2_1_103
      0004C3 75*07 00         [24] 2332 	mov	(_i2c_write_data_PARM_3 + 1),#0x00
      0004C6 75*08 40         [24] 2333 	mov	(_i2c_write_data_PARM_3 + 2),#0x40
      0004C9 75*05 22         [24] 2334 	mov	_i2c_write_data_PARM_2,#0x22
      0004CC 75*09 01         [24] 2335 	mov	_i2c_write_data_PARM_4,#0x01
      0004CF 75 82 30         [24] 2336 	mov	dpl,#0x30
      0004D2 12r03r72         [24] 2337 	lcall	_i2c_write_data
                           0004D5  2338 	C$i2c.h$298$1$103 ==.
                           0004D5  2339 	XG$Accel_Init$0$0 ==.
      0004D5 22               [24] 2340 	ret
                                   2341 ;------------------------------------------------------------
                                   2342 ;Allocation info for local variables in function 'main'
                                   2343 ;------------------------------------------------------------
                                   2344 ;run_stop                  Allocated to registers r7 
                                   2345 ;------------------------------------------------------------
                           0004D6  2346 	G$main$0$0 ==.
                           0004D6  2347 	C$Lab_4.c$61$1$103 ==.
                                   2348 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:61: void main(void)
                                   2349 ;	-----------------------------------------
                                   2350 ;	 function main
                                   2351 ;	-----------------------------------------
      0004D6                       2352 _main:
                           0004D6  2353 	C$Lab_4.c$64$1$119 ==.
                                   2354 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:64: Sys_Init(); // initialize board
      0004D6 12r00r30         [24] 2355 	lcall	_Sys_Init
                           0004D9  2356 	C$Lab_4.c$65$1$119 ==.
                                   2357 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:65: Port_Init();
      0004D9 12r05r35         [24] 2358 	lcall	_Port_Init
                           0004DC  2359 	C$Lab_4.c$66$1$119 ==.
                                   2360 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:66: PCA_Init();
      0004DC 12r05r43         [24] 2361 	lcall	_PCA_Init
                           0004DF  2362 	C$Lab_4.c$68$1$119 ==.
                                   2363 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:68: r_count = 0;
      0004DF 75*24 00         [24] 2364 	mov	_r_count,#0x00
                           0004E2  2365 	C$Lab_4.c$69$1$119 ==.
                                   2366 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:69: h_count = 0;
      0004E2 75*25 00         [24] 2367 	mov	_h_count,#0x00
                           0004E5  2368 	C$Lab_4.c$70$1$119 ==.
                                   2369 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:70: while (1)
      0004E5                       2370 00112$:
                           0004E5  2371 	C$Lab_4.c$72$2$120 ==.
                                   2372 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:72: run_stop = 0;
      0004E5 7F 00            [12] 2373 	mov	r7,#0x00
                           0004E7  2374 	C$Lab_4.c$73$2$120 ==.
                                   2375 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:73: while ((!COMPASS_SWITCH)&&(!RANGER_SWITCH)) // make run an sbit for the run/stop switch
      0004E7                       2376 00104$:
      0004E7 20 B7 1C         [24] 2377 	jb	_COMPASS_SWITCH,00106$
      0004EA 20 B6 19         [24] 2378 	jb	_RANGER_SWITCH,00106$
                           0004ED  2379 	C$Lab_4.c$75$3$121 ==.
                                   2380 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:75: if (run_stop == 0)
      0004ED EF               [12] 2381 	mov	a,r7
      0004EE 70 F7            [24] 2382 	jnz	00104$
                           0004F0  2383 	C$Lab_4.c$77$4$122 ==.
                                   2384 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:77: desired_heading = pick_heading();
      0004F0 12r06rEE         [24] 2385 	lcall	_pick_heading
      0004F3 85 82*26         [24] 2386 	mov	_desired_heading,dpl
      0004F6 85 83*27         [24] 2387 	mov	(_desired_heading + 1),dph
                           0004F9  2388 	C$Lab_4.c$78$4$122 ==.
                                   2389 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:78: desired_range = pick_range();
      0004F9 12r00r00         [24] 2390 	lcall	_pick_range
      0004FC 85 82*28         [24] 2391 	mov	_desired_range,dpl
      0004FF 85 83*29         [24] 2392 	mov	(_desired_range + 1),dph
                           000502  2393 	C$Lab_4.c$79$4$122 ==.
                                   2394 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:79: run_stop = 1; // only try to update desired heading once
      000502 7F 01            [12] 2395 	mov	r7,#0x01
      000504 80 E1            [24] 2396 	sjmp	00104$
      000506                       2397 00106$:
                           000506  2398 	C$Lab_4.c$82$2$120 ==.
                                   2399 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:82: if (new_heading) // enough overflows for a new heading
      000506 E5*1E            [12] 2400 	mov	a,_new_heading
      000508 60 12            [24] 2401 	jz	00108$
                           00050A  2402 	C$Lab_4.c$84$3$123 ==.
                                   2403 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:84: heading = read_compass();
      00050A 12r05rA6         [24] 2404 	lcall	_read_compass
      00050D 85 82*20         [24] 2405 	mov	_heading,dpl
      000510 85 83*21         [24] 2406 	mov	(_heading + 1),dph
                           000513  2407 	C$Lab_4.c$85$3$123 ==.
                                   2408 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:85: set_servo_PWM(); // if new data, adjust servo PWM for compass & ranger
      000513 12r05rCC         [24] 2409 	lcall	_set_servo_PWM
                           000516  2410 	C$Lab_4.c$86$3$123 ==.
                                   2411 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:86: new_heading = 0;
      000516 75*1E 00         [24] 2412 	mov	_new_heading,#0x00
                           000519  2413 	C$Lab_4.c$87$3$123 ==.
                                   2414 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:87: h_count = 0;
      000519 75*25 00         [24] 2415 	mov	_h_count,#0x00
      00051C                       2416 00108$:
                           00051C  2417 	C$Lab_4.c$89$2$120 ==.
                                   2418 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:89: if (new_range) // enough overflow for a new range
      00051C E5*1F            [12] 2419 	mov	a,_new_range
      00051E 60 C5            [24] 2420 	jz	00112$
                           000520  2421 	C$Lab_4.c$91$3$124 ==.
                                   2422 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:91: range = read_ranger(); // get range
      000520 12r06r25         [24] 2423 	lcall	_read_ranger
      000523 85 82*22         [24] 2424 	mov	_range,dpl
      000526 85 83*23         [24] 2425 	mov	(_range + 1),dph
                           000529  2426 	C$Lab_4.c$93$3$124 ==.
                                   2427 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:93: set_range_adj(); // if new data, set value to adjust steering PWM
      000529 12r00r00         [24] 2428 	lcall	_set_range_adj
                           00052C  2429 	C$Lab_4.c$94$3$124 ==.
                                   2430 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:94: new_range = 0;
      00052C 75*1F 00         [24] 2431 	mov	_new_range,#0x00
                           00052F  2432 	C$Lab_4.c$95$3$124 ==.
                                   2433 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:95: r_count = 0;
      00052F 75*24 00         [24] 2434 	mov	_r_count,#0x00
      000532 80 B1            [24] 2435 	sjmp	00112$
                           000534  2436 	C$Lab_4.c$98$1$119 ==.
                           000534  2437 	XG$main$0$0 ==.
      000534 22               [24] 2438 	ret
                                   2439 ;------------------------------------------------------------
                                   2440 ;Allocation info for local variables in function 'Port_Init'
                                   2441 ;------------------------------------------------------------
                           000535  2442 	G$Port_Init$0$0 ==.
                           000535  2443 	C$Lab_4.c$103$1$119 ==.
                                   2444 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:103: void Port_Init()
                                   2445 ;	-----------------------------------------
                                   2446 ;	 function Port_Init
                                   2447 ;	-----------------------------------------
      000535                       2448 _Port_Init:
                           000535  2449 	C$Lab_4.c$105$1$125 ==.
                                   2450 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:105: P1MDOUT |= 0x01; //set output pin for CEX0 in push-pull mode
      000535 43 A5 01         [24] 2451 	orl	_P1MDOUT,#0x01
                           000538  2452 	C$Lab_4.c$106$1$125 ==.
                                   2453 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:106: P3MDOUT &= 0x7F; // set input pin for 3.7 to open-drain
      000538 53 A7 7F         [24] 2454 	anl	_P3MDOUT,#0x7F
                           00053B  2455 	C$Lab_4.c$107$1$125 ==.
                                   2456 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:107: P3		|= ~0x7F;// set input pin for 3.7 to high impedence
      00053B AF B0            [24] 2457 	mov	r7,_P3
      00053D 74 80            [12] 2458 	mov	a,#0x80
      00053F 4F               [12] 2459 	orl	a,r7
      000540 F5 B0            [12] 2460 	mov	_P3,a
                           000542  2461 	C$Lab_4.c$108$1$125 ==.
                           000542  2462 	XG$Port_Init$0$0 ==.
      000542 22               [24] 2463 	ret
                                   2464 ;------------------------------------------------------------
                                   2465 ;Allocation info for local variables in function 'PCA_Init'
                                   2466 ;------------------------------------------------------------
                           000543  2467 	G$PCA_Init$0$0 ==.
                           000543  2468 	C$Lab_4.c$112$1$125 ==.
                                   2469 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:112: void PCA_Init(void)
                                   2470 ;	-----------------------------------------
                                   2471 ;	 function PCA_Init
                                   2472 ;	-----------------------------------------
      000543                       2473 _PCA_Init:
                           000543  2474 	C$Lab_4.c$114$1$127 ==.
                                   2475 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:114: PCA0CPM0 = 0xC2;	// CCM0 in 16-bit compare mode
      000543 75 DA C2         [24] 2476 	mov	_PCA0CPM0,#0xC2
                           000546  2477 	C$Lab_4.c$115$1$127 ==.
                                   2478 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:115: PCA0CN = 0x40;		// Enable PCA Counter
      000546 75 D8 40         [24] 2479 	mov	_PCA0CN,#0x40
                           000549  2480 	C$Lab_4.c$116$1$127 ==.
                                   2481 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:116: PCA0MD = 0x81;		// Enable CF Interrupt and SYSCLK/12
      000549 75 D9 81         [24] 2482 	mov	_PCA0MD,#0x81
                           00054C  2483 	C$Lab_4.c$117$1$127 ==.
                                   2484 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:117: EA = 1;				// Enable Global Interrupts
      00054C D2 AF            [12] 2485 	setb	_EA
                           00054E  2486 	C$Lab_4.c$118$1$127 ==.
                                   2487 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:118: EIE1 |= 0x08;		// Enable PCA Interrupt
      00054E 43 E6 08         [24] 2488 	orl	_EIE1,#0x08
                           000551  2489 	C$Lab_4.c$119$1$127 ==.
                           000551  2490 	XG$PCA_Init$0$0 ==.
      000551 22               [24] 2491 	ret
                                   2492 ;------------------------------------------------------------
                                   2493 ;Allocation info for local variables in function 'PCA_ISR'
                                   2494 ;------------------------------------------------------------
                           000552  2495 	G$PCA_ISR$0$0 ==.
                           000552  2496 	C$Lab_4.c$123$1$127 ==.
                                   2497 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:123: void PCA_ISR(void) __interrupt 9
                                   2498 ;	-----------------------------------------
                                   2499 ;	 function PCA_ISR
                                   2500 ;	-----------------------------------------
      000552                       2501 _PCA_ISR:
      000552 C0 E0            [24] 2502 	push	acc
      000554 C0 D0            [24] 2503 	push	psw
                           000556  2504 	C$Lab_4.c$125$1$129 ==.
                                   2505 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:125: if (CF)
                           000556  2506 	C$Lab_4.c$127$2$130 ==.
                                   2507 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:127: CF = 0; // clear overflow indicator
      000556 10 DF 02         [24] 2508 	jbc	_CF,00123$
      000559 80 2D            [24] 2509 	sjmp	00108$
      00055B                       2510 00123$:
                           00055B  2511 	C$Lab_4.c$128$2$130 ==.
                                   2512 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:128: h_count++;
      00055B 05*25            [12] 2513 	inc	_h_count
                           00055D  2514 	C$Lab_4.c$129$2$130 ==.
                                   2515 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:129: if (h_count>=2)
      00055D 74 FE            [12] 2516 	mov	a,#0x100 - 0x02
      00055F 25*25            [12] 2517 	add	a,_h_count
      000561 50 06            [24] 2518 	jnc	00102$
                           000563  2519 	C$Lab_4.c$131$3$131 ==.
                                   2520 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:131: new_heading=1;
      000563 75*1E 01         [24] 2521 	mov	_new_heading,#0x01
                           000566  2522 	C$Lab_4.c$132$3$131 ==.
                                   2523 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:132: h_count = 0;
      000566 75*25 00         [24] 2524 	mov	_h_count,#0x00
      000569                       2525 00102$:
                           000569  2526 	C$Lab_4.c$134$2$130 ==.
                                   2527 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:134: heading_delay++;
      000569 05*2A            [12] 2528 	inc	_heading_delay
                           00056B  2529 	C$Lab_4.c$135$2$130 ==.
                                   2530 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:135: if(heading_delay>5) heading_delay=0;
      00056B E5*2A            [12] 2531 	mov	a,_heading_delay
      00056D 24 FA            [12] 2532 	add	a,#0xff - 0x05
      00056F 50 03            [24] 2533 	jnc	00104$
      000571 75*2A 00         [24] 2534 	mov	_heading_delay,#0x00
      000574                       2535 00104$:
                           000574  2536 	C$Lab_4.c$136$2$130 ==.
                                   2537 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:136: r_count++;
      000574 05*24            [12] 2538 	inc	_r_count
                           000576  2539 	C$Lab_4.c$137$2$130 ==.
                                   2540 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:137: if (r_count>=4)
      000576 74 FC            [12] 2541 	mov	a,#0x100 - 0x04
      000578 25*24            [12] 2542 	add	a,_r_count
      00057A 50 06            [24] 2543 	jnc	00106$
                           00057C  2544 	C$Lab_4.c$139$3$132 ==.
                                   2545 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:139: new_range = 1;
      00057C 75*1F 01         [24] 2546 	mov	_new_range,#0x01
                           00057F  2547 	C$Lab_4.c$140$3$132 ==.
                                   2548 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:140: r_count = 0;
      00057F 75*24 00         [24] 2549 	mov	_r_count,#0x00
      000582                       2550 00106$:
                           000582  2551 	C$Lab_4.c$142$2$130 ==.
                                   2552 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:142: PCA0 = PCA_START;
      000582 85*1C E9         [24] 2553 	mov	((_PCA0 >> 0) & 0xFF),_PCA_START
      000585 85*1D F9         [24] 2554 	mov	((_PCA0 >> 8) & 0xFF),(_PCA_START + 1)
      000588                       2555 00108$:
                           000588  2556 	C$Lab_4.c$145$1$129 ==.
                                   2557 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:145: PCA0CN &= 0xC0;
      000588 53 D8 C0         [24] 2558 	anl	_PCA0CN,#0xC0
      00058B D0 D0            [24] 2559 	pop	psw
      00058D D0 E0            [24] 2560 	pop	acc
                           00058F  2561 	C$Lab_4.c$146$1$129 ==.
                           00058F  2562 	XG$PCA_ISR$0$0 ==.
      00058F 32               [24] 2563 	reti
                                   2564 ;	eliminated unneeded mov psw,# (no regs used in bank)
                                   2565 ;	eliminated unneeded push/pop dpl
                                   2566 ;	eliminated unneeded push/pop dph
                                   2567 ;	eliminated unneeded push/pop b
                                   2568 ;------------------------------------------------------------
                                   2569 ;Allocation info for local variables in function 'SMB_Init'
                                   2570 ;------------------------------------------------------------
                           000590  2571 	G$SMB_Init$0$0 ==.
                           000590  2572 	C$Lab_4.c$150$1$129 ==.
                                   2573 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:150: void SMB_Init(void)
                                   2574 ;	-----------------------------------------
                                   2575 ;	 function SMB_Init
                                   2576 ;	-----------------------------------------
      000590                       2577 _SMB_Init:
                           000590  2578 	C$Lab_4.c$152$1$134 ==.
                                   2579 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:152: SMB0CR=0x93;	//Set SCL to 100KHz
      000590 75 CF 93         [24] 2580 	mov	_SMB0CR,#0x93
                           000593  2581 	C$Lab_4.c$153$1$134 ==.
                                   2582 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:153: ENSMB=1; 		//Bit 6 of SMB0CN, enable the SMBus
      000593 D2 C6            [12] 2583 	setb	_ENSMB
                           000595  2584 	C$Lab_4.c$154$1$134 ==.
                           000595  2585 	XG$SMB_Init$0$0 ==.
      000595 22               [24] 2586 	ret
                                   2587 ;------------------------------------------------------------
                                   2588 ;Allocation info for local variables in function 'ADC_Init'
                                   2589 ;------------------------------------------------------------
                           000596  2590 	G$ADC_Init$0$0 ==.
                           000596  2591 	C$Lab_4.c$157$1$134 ==.
                                   2592 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:157: void ADC_Init(void)
                                   2593 ;	-----------------------------------------
                                   2594 ;	 function ADC_Init
                                   2595 ;	-----------------------------------------
      000596                       2596 _ADC_Init:
                           000596  2597 	C$Lab_4.c$159$1$136 ==.
                                   2598 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:159: REF0CN = 0x03;	// Set Vref to use internal reference voltage (2.4 V)
      000596 75 D1 03         [24] 2599 	mov	_REF0CN,#0x03
                           000599  2600 	C$Lab_4.c$160$1$136 ==.
                                   2601 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:160: ADC1CN = 0x80;	// Enable A/D converter (ADC1)
      000599 75 AA 80         [24] 2602 	mov	_ADC1CN,#0x80
                           00059C  2603 	C$Lab_4.c$161$1$136 ==.
                                   2604 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:161: ADC1CF |= 0x01; // Set A/D converter gain to 1
      00059C 43 AB 01         [24] 2605 	orl	_ADC1CF,#0x01
                           00059F  2606 	C$Lab_4.c$162$1$136 ==.
                           00059F  2607 	XG$ADC_Init$0$0 ==.
      00059F 22               [24] 2608 	ret
                                   2609 ;------------------------------------------------------------
                                   2610 ;Allocation info for local variables in function 'Interrupt_Init'
                                   2611 ;------------------------------------------------------------
                           0005A0  2612 	G$Interrupt_Init$0$0 ==.
                           0005A0  2613 	C$Lab_4.c$166$1$136 ==.
                                   2614 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:166: void Interrupt_Init(void)
                                   2615 ;	-----------------------------------------
                                   2616 ;	 function Interrupt_Init
                                   2617 ;	-----------------------------------------
      0005A0                       2618 _Interrupt_Init:
                           0005A0  2619 	C$Lab_4.c$168$1$138 ==.
                                   2620 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:168: EIE1 |= 0x08;	//Enable PCA0 Interrupt (bit 3) 
      0005A0 43 E6 08         [24] 2621 	orl	_EIE1,#0x08
                           0005A3  2622 	C$Lab_4.c$169$1$138 ==.
                                   2623 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:169: EA = 1;			//Enable global interrupts
      0005A3 D2 AF            [12] 2624 	setb	_EA
                           0005A5  2625 	C$Lab_4.c$170$1$138 ==.
                           0005A5  2626 	XG$Interrupt_Init$0$0 ==.
      0005A5 22               [24] 2627 	ret
                                   2628 ;------------------------------------------------------------
                                   2629 ;Allocation info for local variables in function 'read_compass'
                                   2630 ;------------------------------------------------------------
                                   2631 ;addr                      Allocated to registers 
                                   2632 ;Data                      Allocated with name '_read_compass_Data_1_140'
                                   2633 ;read_heading              Allocated to registers 
                                   2634 ;------------------------------------------------------------
                           0005A6  2635 	G$read_compass$0$0 ==.
                           0005A6  2636 	C$Lab_4.c$174$1$138 ==.
                                   2637 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:174: int read_compass(void)
                                   2638 ;	-----------------------------------------
                                   2639 ;	 function read_compass
                                   2640 ;	-----------------------------------------
      0005A6                       2641 _read_compass:
                           0005A6  2642 	C$Lab_4.c$179$1$140 ==.
                                   2643 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:179: i2c_read_data(addr, 2, Data, 2); // read two byte, starting at reg 2
      0005A6 75*0Br2F         [24] 2644 	mov	_i2c_read_data_PARM_3,#_read_compass_Data_1_140
      0005A9 75*0C 00         [24] 2645 	mov	(_i2c_read_data_PARM_3 + 1),#0x00
      0005AC 75*0D 40         [24] 2646 	mov	(_i2c_read_data_PARM_3 + 2),#0x40
      0005AF 75*0A 02         [24] 2647 	mov	_i2c_read_data_PARM_2,#0x02
      0005B2 75*0E 02         [24] 2648 	mov	_i2c_read_data_PARM_4,#0x02
      0005B5 75 82 C0         [24] 2649 	mov	dpl,#0xC0
      0005B8 12r03rE8         [24] 2650 	lcall	_i2c_read_data
                           0005BB  2651 	C$Lab_4.c$180$1$140 ==.
                                   2652 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:180: read_heading =(((unsigned int)Data[0] << 8) | Data[1]); //combine the two values
      0005BB AF*2F            [24] 2653 	mov	r7,_read_compass_Data_1_140
      0005BD 7E 00            [12] 2654 	mov	r6,#0x00
      0005BF AC*30            [24] 2655 	mov	r4,(_read_compass_Data_1_140 + 0x0001)
      0005C1 7D 00            [12] 2656 	mov	r5,#0x00
      0005C3 EC               [12] 2657 	mov	a,r4
      0005C4 4E               [12] 2658 	orl	a,r6
      0005C5 F5 82            [12] 2659 	mov	dpl,a
      0005C7 ED               [12] 2660 	mov	a,r5
      0005C8 4F               [12] 2661 	orl	a,r7
      0005C9 F5 83            [12] 2662 	mov	dph,a
                           0005CB  2663 	C$Lab_4.c$181$1$140 ==.
                                   2664 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:181: return read_heading; // the heading returned in degrees between 0 and 3599
                           0005CB  2665 	C$Lab_4.c$182$1$140 ==.
                           0005CB  2666 	XG$read_compass$0$0 ==.
      0005CB 22               [24] 2667 	ret
                                   2668 ;------------------------------------------------------------
                                   2669 ;Allocation info for local variables in function 'set_servo_PWM'
                                   2670 ;------------------------------------------------------------
                           0005CC  2671 	G$set_servo_PWM$0$0 ==.
                           0005CC  2672 	C$Lab_4.c$185$1$140 ==.
                                   2673 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:185: void set_servo_PWM(void)
                                   2674 ;	-----------------------------------------
                                   2675 ;	 function set_servo_PWM
                                   2676 ;	-----------------------------------------
      0005CC                       2677 _set_servo_PWM:
                           0005CC  2678 	C$Lab_4.c$187$1$142 ==.
                                   2679 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:187: if(new_heading && (heading_delay>=5))
      0005CC E5*1E            [12] 2680 	mov	a,_new_heading
      0005CE 60 54            [24] 2681 	jz	00104$
      0005D0 74 FB            [12] 2682 	mov	a,#0x100 - 0x05
      0005D2 25*2A            [12] 2683 	add	a,_heading_delay
      0005D4 50 4E            [24] 2684 	jnc	00104$
                           0005D6  2685 	C$Lab_4.c$189$2$143 ==.
                                   2686 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:189: heading = read_compass();
      0005D6 12r05rA6         [24] 2687 	lcall	_read_compass
                           0005D9  2688 	C$Lab_4.c$190$1$142 ==.
                                   2689 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:190: printf("\rThe current direction is %u\n", heading/10);
      0005D9 85 82*20         [24] 2690 	mov	_heading,dpl
      0005DC 85 83*21         [24] 2691 	mov	(_heading + 1),dph
      0005DF 75*00 0A         [24] 2692 	mov	__divuint_PARM_2,#0x0A
      0005E2 75*01 00         [24] 2693 	mov	(__divuint_PARM_2 + 1),#0x00
      0005E5 12r00r00         [24] 2694 	lcall	__divuint
      0005E8 AE 82            [24] 2695 	mov	r6,dpl
      0005EA AF 83            [24] 2696 	mov	r7,dph
      0005EC C0 06            [24] 2697 	push	ar6
      0005EE C0 07            [24] 2698 	push	ar7
      0005F0 74r29            [12] 2699 	mov	a,#___str_3
      0005F2 C0 E0            [24] 2700 	push	acc
      0005F4 74s00            [12] 2701 	mov	a,#(___str_3 >> 8)
      0005F6 C0 E0            [24] 2702 	push	acc
      0005F8 74 80            [12] 2703 	mov	a,#0x80
      0005FA C0 E0            [24] 2704 	push	acc
      0005FC 12r00r00         [24] 2705 	lcall	_printf
      0005FF E5 81            [12] 2706 	mov	a,sp
      000601 24 FB            [12] 2707 	add	a,#0xfb
      000603 F5 81            [12] 2708 	mov	sp,a
                           000605  2709 	C$Lab_4.c$191$2$143 ==.
                                   2710 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:191: COMPASS_PW = servo_error(heading); // Adjust pulsewidth based on error function
      000605 85*20 82         [24] 2711 	mov	dpl,_heading
      000608 85*21 83         [24] 2712 	mov	dph,(_heading + 1)
      00060B 12r07r55         [24] 2713 	lcall	_servo_error
      00060E 85 82*2B         [24] 2714 	mov	_COMPASS_PW,dpl
      000611 85 83*2C         [24] 2715 	mov	(_COMPASS_PW + 1),dph
                           000614  2716 	C$Lab_4.c$192$2$143 ==.
                                   2717 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:192: PCA0CP0 = 0xFFFF - COMPASS_PW; // Change pulse width
      000614 74 FF            [12] 2718 	mov	a,#0xFF
      000616 C3               [12] 2719 	clr	c
      000617 95*2B            [12] 2720 	subb	a,_COMPASS_PW
      000619 F5 EA            [12] 2721 	mov	((_PCA0CP0 >> 0) & 0xFF),a
      00061B 74 FF            [12] 2722 	mov	a,#0xFF
      00061D 95*2C            [12] 2723 	subb	a,(_COMPASS_PW + 1)
      00061F F5 FA            [12] 2724 	mov	((_PCA0CP0 >> 8) & 0xFF),a
                           000621  2725 	C$Lab_4.c$193$2$143 ==.
                                   2726 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:193: new_heading = 0;
      000621 75*1E 00         [24] 2727 	mov	_new_heading,#0x00
      000624                       2728 00104$:
                           000624  2729 	C$Lab_4.c$195$1$142 ==.
                           000624  2730 	XG$set_servo_PWM$0$0 ==.
      000624 22               [24] 2731 	ret
                                   2732 ;------------------------------------------------------------
                                   2733 ;Allocation info for local variables in function 'read_ranger'
                                   2734 ;------------------------------------------------------------
                                   2735 ;addr                      Allocated to registers 
                                   2736 ;Data                      Allocated with name '_read_ranger_Data_1_145'
                                   2737 ;range                     Allocated to registers r6 r7 
                                   2738 ;------------------------------------------------------------
                           000625  2739 	G$read_ranger$0$0 ==.
                           000625  2740 	C$Lab_4.c$199$1$142 ==.
                                   2741 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:199: int read_ranger(void)
                                   2742 ;	-----------------------------------------
                                   2743 ;	 function read_ranger
                                   2744 ;	-----------------------------------------
      000625                       2745 _read_ranger:
                           000625  2746 	C$Lab_4.c$204$1$145 ==.
                                   2747 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:204: i2c_read_data(addr, 2, Data, 2); // read two byte, starting at reg 2
      000625 75*0Br31         [24] 2748 	mov	_i2c_read_data_PARM_3,#_read_ranger_Data_1_145
      000628 75*0C 00         [24] 2749 	mov	(_i2c_read_data_PARM_3 + 1),#0x00
      00062B 75*0D 40         [24] 2750 	mov	(_i2c_read_data_PARM_3 + 2),#0x40
      00062E 75*0A 02         [24] 2751 	mov	_i2c_read_data_PARM_2,#0x02
      000631 75*0E 02         [24] 2752 	mov	_i2c_read_data_PARM_4,#0x02
      000634 75 82 E0         [24] 2753 	mov	dpl,#0xE0
      000637 12r03rE8         [24] 2754 	lcall	_i2c_read_data
                           00063A  2755 	C$Lab_4.c$205$1$145 ==.
                                   2756 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:205: range =(((unsigned int)Data[0] << 8) | Data[1]); //combine the two values	
      00063A AF*31            [24] 2757 	mov	r7,_read_ranger_Data_1_145
      00063C 7E 00            [12] 2758 	mov	r6,#0x00
      00063E AC*32            [24] 2759 	mov	r4,(_read_ranger_Data_1_145 + 0x0001)
      000640 7D 00            [12] 2760 	mov	r5,#0x00
      000642 EC               [12] 2761 	mov	a,r4
      000643 42 06            [12] 2762 	orl	ar6,a
      000645 ED               [12] 2763 	mov	a,r5
      000646 42 07            [12] 2764 	orl	ar7,a
                           000648  2765 	C$Lab_4.c$206$1$145 ==.
                                   2766 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:206: Data[0] = 0x51 ; // write 0x51 to reg 0 of the ranger:
      000648 75*31 51         [24] 2767 	mov	_read_ranger_Data_1_145,#0x51
                           00064B  2768 	C$Lab_4.c$207$1$145 ==.
                                   2769 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:207: i2c_write_data(addr, 0, Data, 1) ; // write one byte of data to reg 0 at addr
      00064B 75*06r31         [24] 2770 	mov	_i2c_write_data_PARM_3,#_read_ranger_Data_1_145
      00064E 75*07 00         [24] 2771 	mov	(_i2c_write_data_PARM_3 + 1),#0x00
      000651 75*08 40         [24] 2772 	mov	(_i2c_write_data_PARM_3 + 2),#0x40
      000654 75*05 00         [24] 2773 	mov	_i2c_write_data_PARM_2,#0x00
      000657 75*09 01         [24] 2774 	mov	_i2c_write_data_PARM_4,#0x01
      00065A 75 82 E0         [24] 2775 	mov	dpl,#0xE0
      00065D C0 07            [24] 2776 	push	ar7
      00065F C0 06            [24] 2777 	push	ar6
      000661 12r03r72         [24] 2778 	lcall	_i2c_write_data
      000664 D0 06            [24] 2779 	pop	ar6
      000666 D0 07            [24] 2780 	pop	ar7
                           000668  2781 	C$Lab_4.c$208$1$145 ==.
                                   2782 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:208: return range;
      000668 8E 82            [24] 2783 	mov	dpl,r6
      00066A 8F 83            [24] 2784 	mov	dph,r7
                           00066C  2785 	C$Lab_4.c$209$1$145 ==.
                           00066C  2786 	XG$read_ranger$0$0 ==.
      00066C 22               [24] 2787 	ret
                                   2788 ;------------------------------------------------------------
                                   2789 ;Allocation info for local variables in function 'set_drive_PWM'
                                   2790 ;------------------------------------------------------------
                           00066D  2791 	G$set_drive_PWM$0$0 ==.
                           00066D  2792 	C$Lab_4.c$212$1$145 ==.
                                   2793 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:212: void set_drive_PWM(void)
                                   2794 ;	-----------------------------------------
                                   2795 ;	 function set_drive_PWM
                                   2796 ;	-----------------------------------------
      00066D                       2797 _set_drive_PWM:
                           00066D  2798 	C$Lab_4.c$214$1$147 ==.
                                   2799 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:214: if(new_range)
      00066D E5*1F            [12] 2800 	mov	a,_new_range
      00066F 60 3E            [24] 2801 	jz	00102$
                           000671  2802 	C$Lab_4.c$216$2$148 ==.
                                   2803 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:216: range = read_ranger();
      000671 12r06r25         [24] 2804 	lcall	_read_ranger
      000674 85 82*22         [24] 2805 	mov	_range,dpl
      000677 85 83*23         [24] 2806 	mov	(_range + 1),dph
                           00067A  2807 	C$Lab_4.c$217$2$148 ==.
                                   2808 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:217: new_range = 0;
      00067A 75*1F 00         [24] 2809 	mov	_new_range,#0x00
                           00067D  2810 	C$Lab_4.c$218$2$148 ==.
                                   2811 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:218: printf("\rThe range is %u cm\n",range);
      00067D C0*22            [24] 2812 	push	_range
      00067F C0*23            [24] 2813 	push	(_range + 1)
      000681 74r47            [12] 2814 	mov	a,#___str_4
      000683 C0 E0            [24] 2815 	push	acc
      000685 74s00            [12] 2816 	mov	a,#(___str_4 >> 8)
      000687 C0 E0            [24] 2817 	push	acc
      000689 74 80            [12] 2818 	mov	a,#0x80
      00068B C0 E0            [24] 2819 	push	acc
      00068D 12r00r00         [24] 2820 	lcall	_printf
      000690 E5 81            [12] 2821 	mov	a,sp
      000692 24 FB            [12] 2822 	add	a,#0xfb
      000694 F5 81            [12] 2823 	mov	sp,a
                           000696  2824 	C$Lab_4.c$219$2$148 ==.
                                   2825 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:219: printf("\rPW is %u\n", RANGER_PW);
      000696 C0*2D            [24] 2826 	push	_RANGER_PW
      000698 C0*2E            [24] 2827 	push	(_RANGER_PW + 1)
      00069A 74r5C            [12] 2828 	mov	a,#___str_5
      00069C C0 E0            [24] 2829 	push	acc
      00069E 74s00            [12] 2830 	mov	a,#(___str_5 >> 8)
      0006A0 C0 E0            [24] 2831 	push	acc
      0006A2 74 80            [12] 2832 	mov	a,#0x80
      0006A4 C0 E0            [24] 2833 	push	acc
      0006A6 12r00r00         [24] 2834 	lcall	_printf
      0006A9 E5 81            [12] 2835 	mov	a,sp
      0006AB 24 FB            [12] 2836 	add	a,#0xfb
      0006AD F5 81            [12] 2837 	mov	sp,a
      0006AF                       2838 00102$:
                           0006AF  2839 	C$Lab_4.c$221$1$147 ==.
                                   2840 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:221: RANGER_PW = motor_error(range);	//Adjust Pulsewidth for motor control
      0006AF 85*22 82         [24] 2841 	mov	dpl,_range
      0006B2 85*23 83         [24] 2842 	mov	dph,(_range + 1)
      0006B5 12r07rC6         [24] 2843 	lcall	_motor_error
      0006B8 85 82*2D         [24] 2844 	mov	_RANGER_PW,dpl
      0006BB 85 83*2E         [24] 2845 	mov	(_RANGER_PW + 1),dph
                           0006BE  2846 	C$Lab_4.c$222$1$147 ==.
                                   2847 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:222: if(RANGER_PW > RANGER_MAX) RANGER_PW = RANGER_MAX;
      0006BE C3               [12] 2848 	clr	c
      0006BF E5*18            [12] 2849 	mov	a,_RANGER_MAX
      0006C1 95*2D            [12] 2850 	subb	a,_RANGER_PW
      0006C3 E5*19            [12] 2851 	mov	a,(_RANGER_MAX + 1)
      0006C5 95*2E            [12] 2852 	subb	a,(_RANGER_PW + 1)
      0006C7 50 06            [24] 2853 	jnc	00104$
      0006C9 85*18*2D         [24] 2854 	mov	_RANGER_PW,_RANGER_MAX
      0006CC 85*19*2E         [24] 2855 	mov	(_RANGER_PW + 1),(_RANGER_MAX + 1)
      0006CF                       2856 00104$:
                           0006CF  2857 	C$Lab_4.c$223$1$147 ==.
                                   2858 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:223: if(RANGER_PW < RANGER_MIN) RANGER_PW = RANGER_MIN;
      0006CF C3               [12] 2859 	clr	c
      0006D0 E5*2D            [12] 2860 	mov	a,_RANGER_PW
      0006D2 95*1A            [12] 2861 	subb	a,_RANGER_MIN
      0006D4 E5*2E            [12] 2862 	mov	a,(_RANGER_PW + 1)
      0006D6 95*1B            [12] 2863 	subb	a,(_RANGER_MIN + 1)
      0006D8 50 06            [24] 2864 	jnc	00106$
      0006DA 85*1A*2D         [24] 2865 	mov	_RANGER_PW,_RANGER_MIN
      0006DD 85*1B*2E         [24] 2866 	mov	(_RANGER_PW + 1),(_RANGER_MIN + 1)
      0006E0                       2867 00106$:
                           0006E0  2868 	C$Lab_4.c$224$1$147 ==.
                                   2869 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:224: PCA0CP2 = 0xFFFF - RANGER_PW;	
      0006E0 74 FF            [12] 2870 	mov	a,#0xFF
      0006E2 C3               [12] 2871 	clr	c
      0006E3 95*2D            [12] 2872 	subb	a,_RANGER_PW
      0006E5 F5 EC            [12] 2873 	mov	((_PCA0CP2 >> 0) & 0xFF),a
      0006E7 74 FF            [12] 2874 	mov	a,#0xFF
      0006E9 95*2E            [12] 2875 	subb	a,(_RANGER_PW + 1)
      0006EB F5 FC            [12] 2876 	mov	((_PCA0CP2 >> 8) & 0xFF),a
                           0006ED  2877 	C$Lab_4.c$225$1$147 ==.
                           0006ED  2878 	XG$set_drive_PWM$0$0 ==.
      0006ED 22               [24] 2879 	ret
                                   2880 ;------------------------------------------------------------
                                   2881 ;Allocation info for local variables in function 'pick_heading'
                                   2882 ;------------------------------------------------------------
                                   2883 ;input_heading             Allocated to registers r6 r7 
                                   2884 ;------------------------------------------------------------
                           0006EE  2885 	G$pick_heading$0$0 ==.
                           0006EE  2886 	C$Lab_4.c$229$1$147 ==.
                                   2887 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:229: int pick_heading(void)
                                   2888 ;	-----------------------------------------
                                   2889 ;	 function pick_heading
                                   2890 ;	-----------------------------------------
      0006EE                       2891 _pick_heading:
                           0006EE  2892 	C$Lab_4.c$232$1$150 ==.
                                   2893 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:232: printf("\rInput desired heading on keypad, in degrees.\n");
      0006EE 74r67            [12] 2894 	mov	a,#___str_6
      0006F0 C0 E0            [24] 2895 	push	acc
      0006F2 74s00            [12] 2896 	mov	a,#(___str_6 >> 8)
      0006F4 C0 E0            [24] 2897 	push	acc
      0006F6 74 80            [12] 2898 	mov	a,#0x80
      0006F8 C0 E0            [24] 2899 	push	acc
      0006FA 12r00r00         [24] 2900 	lcall	_printf
      0006FD 15 81            [12] 2901 	dec	sp
      0006FF 15 81            [12] 2902 	dec	sp
      000701 15 81            [12] 2903 	dec	sp
                           000703  2904 	C$Lab_4.c$233$1$150 ==.
                                   2905 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:233: printf("\rAny number above 360 will be interpreted as 360.\n");
      000703 74r96            [12] 2906 	mov	a,#___str_7
      000705 C0 E0            [24] 2907 	push	acc
      000707 74s00            [12] 2908 	mov	a,#(___str_7 >> 8)
      000709 C0 E0            [24] 2909 	push	acc
      00070B 74 80            [12] 2910 	mov	a,#0x80
      00070D C0 E0            [24] 2911 	push	acc
      00070F 12r00r00         [24] 2912 	lcall	_printf
      000712 15 81            [12] 2913 	dec	sp
      000714 15 81            [12] 2914 	dec	sp
      000716 15 81            [12] 2915 	dec	sp
                           000718  2916 	C$Lab_4.c$234$1$150 ==.
                                   2917 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:234: input_heading = kpd_input(1);
      000718 75 82 01         [24] 2918 	mov	dpl,#0x01
      00071B 12r01r99         [24] 2919 	lcall	_kpd_input
      00071E AE 82            [24] 2920 	mov	r6,dpl
      000720 AF 83            [24] 2921 	mov	r7,dph
                           000722  2922 	C$Lab_4.c$235$1$150 ==.
                                   2923 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:235: if(input_heading >= 360) input_heading = 0;
      000722 C3               [12] 2924 	clr	c
      000723 EE               [12] 2925 	mov	a,r6
      000724 94 68            [12] 2926 	subb	a,#0x68
      000726 EF               [12] 2927 	mov	a,r7
      000727 94 01            [12] 2928 	subb	a,#0x01
      000729 40 04            [24] 2929 	jc	00102$
      00072B 7E 00            [12] 2930 	mov	r6,#0x00
      00072D 7F 00            [12] 2931 	mov	r7,#0x00
      00072F                       2932 00102$:
                           00072F  2933 	C$Lab_4.c$236$1$150 ==.
                                   2934 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:236: printf("\rDesired heading is %u degrees", input_heading);
      00072F C0 07            [24] 2935 	push	ar7
      000731 C0 06            [24] 2936 	push	ar6
      000733 C0 06            [24] 2937 	push	ar6
      000735 C0 07            [24] 2938 	push	ar7
      000737 74rC9            [12] 2939 	mov	a,#___str_8
      000739 C0 E0            [24] 2940 	push	acc
      00073B 74s00            [12] 2941 	mov	a,#(___str_8 >> 8)
      00073D C0 E0            [24] 2942 	push	acc
      00073F 74 80            [12] 2943 	mov	a,#0x80
      000741 C0 E0            [24] 2944 	push	acc
      000743 12r00r00         [24] 2945 	lcall	_printf
      000746 E5 81            [12] 2946 	mov	a,sp
      000748 24 FB            [12] 2947 	add	a,#0xfb
      00074A F5 81            [12] 2948 	mov	sp,a
      00074C D0 06            [24] 2949 	pop	ar6
      00074E D0 07            [24] 2950 	pop	ar7
                           000750  2951 	C$Lab_4.c$237$1$150 ==.
                                   2952 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:237: return input_heading;
      000750 8E 82            [24] 2953 	mov	dpl,r6
      000752 8F 83            [24] 2954 	mov	dph,r7
                           000754  2955 	C$Lab_4.c$238$1$150 ==.
                           000754  2956 	XG$pick_heading$0$0 ==.
      000754 22               [24] 2957 	ret
                                   2958 ;------------------------------------------------------------
                                   2959 ;Allocation info for local variables in function 'servo_error'
                                   2960 ;------------------------------------------------------------
                                   2961 ;heading                   Allocated to registers r6 r7 
                                   2962 ;Error                     Allocated to registers r6 r7 
                                   2963 ;PWMe                      Allocated to registers r6 r7 
                                   2964 ;k                         Allocated to registers r5 
                                   2965 ;------------------------------------------------------------
                           000755  2966 	G$servo_error$0$0 ==.
                           000755  2967 	C$Lab_4.c$240$1$150 ==.
                                   2968 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:240: signed int servo_error(unsigned int heading)
                                   2969 ;	-----------------------------------------
                                   2970 ;	 function servo_error
                                   2971 ;	-----------------------------------------
      000755                       2972 _servo_error:
      000755 AE 82            [24] 2973 	mov	r6,dpl
      000757 AF 83            [24] 2974 	mov	r7,dph
                           000759  2975 	C$Lab_4.c$244$1$150 ==.
                                   2976 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:244: unsigned char k = 1;				//Gain constant. Higher numbers turn more, lower numbers turn less.
      000759 7D 01            [12] 2977 	mov	r5,#0x01
                           00075B  2978 	C$Lab_4.c$245$1$152 ==.
                                   2979 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:245: Error = (desired_heading) - heading;	//Calculate the error
      00075B E5*26            [12] 2980 	mov	a,_desired_heading
      00075D C3               [12] 2981 	clr	c
      00075E 9E               [12] 2982 	subb	a,r6
      00075F FE               [12] 2983 	mov	r6,a
      000760 E5*27            [12] 2984 	mov	a,(_desired_heading + 1)
      000762 9F               [12] 2985 	subb	a,r7
      000763 FF               [12] 2986 	mov	r7,a
                           000764  2987 	C$Lab_4.c$246$1$152 ==.
                                   2988 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:246: if(Error < 1800) Error = Error + 3600;	//Adjust the Error for +/- 180 degrees
      000764 C3               [12] 2989 	clr	c
      000765 EE               [12] 2990 	mov	a,r6
      000766 94 08            [12] 2991 	subb	a,#0x08
      000768 EF               [12] 2992 	mov	a,r7
      000769 64 80            [12] 2993 	xrl	a,#0x80
      00076B 94 87            [12] 2994 	subb	a,#0x87
      00076D 50 08            [24] 2995 	jnc	00102$
      00076F 74 10            [12] 2996 	mov	a,#0x10
      000771 2E               [12] 2997 	add	a,r6
      000772 FE               [12] 2998 	mov	r6,a
      000773 74 0E            [12] 2999 	mov	a,#0x0E
      000775 3F               [12] 3000 	addc	a,r7
      000776 FF               [12] 3001 	mov	r7,a
      000777                       3002 00102$:
                           000777  3003 	C$Lab_4.c$247$1$152 ==.
                                   3004 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:247: if(Error > 1800) Error = Error - 3600;
      000777 C3               [12] 3005 	clr	c
      000778 74 08            [12] 3006 	mov	a,#0x08
      00077A 9E               [12] 3007 	subb	a,r6
      00077B 74 87            [12] 3008 	mov	a,#(0x07 ^ 0x80)
      00077D 8F F0            [24] 3009 	mov	b,r7
      00077F 63 F0 80         [24] 3010 	xrl	b,#0x80
      000782 95 F0            [12] 3011 	subb	a,b
      000784 50 08            [24] 3012 	jnc	00104$
      000786 EE               [12] 3013 	mov	a,r6
      000787 24 F0            [12] 3014 	add	a,#0xF0
      000789 FE               [12] 3015 	mov	r6,a
      00078A EF               [12] 3016 	mov	a,r7
      00078B 34 F1            [12] 3017 	addc	a,#0xF1
      00078D FF               [12] 3018 	mov	r7,a
      00078E                       3019 00104$:
                           00078E  3020 	C$Lab_4.c$248$1$152 ==.
                                   3021 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:248: PWMe = COMPASS_CENTER + (k*Error);
      00078E 7C 00            [12] 3022 	mov	r4,#0x00
      000790 8E*00            [24] 3023 	mov	__mulint_PARM_2,r6
      000792 8F*01            [24] 3024 	mov	(__mulint_PARM_2 + 1),r7
      000794 8D 82            [24] 3025 	mov	dpl,r5
      000796 8C 83            [24] 3026 	mov	dph,r4
      000798 12r00r00         [24] 3027 	lcall	__mulint
      00079B AE 82            [24] 3028 	mov	r6,dpl
      00079D AF 83            [24] 3029 	mov	r7,dph
      00079F EE               [12] 3030 	mov	a,r6
      0007A0 25*10            [12] 3031 	add	a,_COMPASS_CENTER
      0007A2 FE               [12] 3032 	mov	r6,a
      0007A3 EF               [12] 3033 	mov	a,r7
      0007A4 35*11            [12] 3034 	addc	a,(_COMPASS_CENTER + 1)
      0007A6 FF               [12] 3035 	mov	r7,a
                           0007A7  3036 	C$Lab_4.c$249$1$152 ==.
                                   3037 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:249: if(PWMe < COMPASS_MIN) PWMe = COMPASS_MIN;
      0007A7 C3               [12] 3038 	clr	c
      0007A8 EE               [12] 3039 	mov	a,r6
      0007A9 95*14            [12] 3040 	subb	a,_COMPASS_MIN
      0007AB EF               [12] 3041 	mov	a,r7
      0007AC 95*15            [12] 3042 	subb	a,(_COMPASS_MIN + 1)
      0007AE 50 04            [24] 3043 	jnc	00106$
      0007B0 AE*14            [24] 3044 	mov	r6,_COMPASS_MIN
      0007B2 AF*15            [24] 3045 	mov	r7,(_COMPASS_MIN + 1)
      0007B4                       3046 00106$:
                           0007B4  3047 	C$Lab_4.c$250$1$152 ==.
                                   3048 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:250: if(PWMe > COMPASS_MAX) PWMe = COMPASS_MAX;
      0007B4 C3               [12] 3049 	clr	c
      0007B5 E5*12            [12] 3050 	mov	a,_COMPASS_MAX
      0007B7 9E               [12] 3051 	subb	a,r6
      0007B8 E5*13            [12] 3052 	mov	a,(_COMPASS_MAX + 1)
      0007BA 9F               [12] 3053 	subb	a,r7
      0007BB 50 04            [24] 3054 	jnc	00108$
      0007BD AE*12            [24] 3055 	mov	r6,_COMPASS_MAX
      0007BF AF*13            [24] 3056 	mov	r7,(_COMPASS_MAX + 1)
      0007C1                       3057 00108$:
                           0007C1  3058 	C$Lab_4.c$251$1$152 ==.
                                   3059 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:251: return PWMe;
      0007C1 8E 82            [24] 3060 	mov	dpl,r6
      0007C3 8F 83            [24] 3061 	mov	dph,r7
                           0007C5  3062 	C$Lab_4.c$252$1$152 ==.
                           0007C5  3063 	XG$servo_error$0$0 ==.
      0007C5 22               [24] 3064 	ret
                                   3065 ;------------------------------------------------------------
                                   3066 ;Allocation info for local variables in function 'motor_error'
                                   3067 ;------------------------------------------------------------
                                   3068 ;range                     Allocated to registers r6 r7 
                                   3069 ;Error                     Allocated to registers r6 r7 
                                   3070 ;PWMe                      Allocated to registers r4 r5 
                                   3071 ;k                         Allocated to registers 
                                   3072 ;------------------------------------------------------------
                           0007C6  3073 	G$motor_error$0$0 ==.
                           0007C6  3074 	C$Lab_4.c$254$1$152 ==.
                                   3075 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:254: signed int motor_error(unsigned int range)
                                   3076 ;	-----------------------------------------
                                   3077 ;	 function motor_error
                                   3078 ;	-----------------------------------------
      0007C6                       3079 _motor_error:
      0007C6 AE 82            [24] 3080 	mov	r6,dpl
      0007C8 AF 83            [24] 3081 	mov	r7,dph
                           0007CA  3082 	C$Lab_4.c$259$1$154 ==.
                                   3083 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:259: Error = (desired_range) - range;	// Calculate the error
      0007CA E5*28            [12] 3084 	mov	a,_desired_range
      0007CC C3               [12] 3085 	clr	c
      0007CD 9E               [12] 3086 	subb	a,r6
      0007CE FE               [12] 3087 	mov	r6,a
      0007CF E5*29            [12] 3088 	mov	a,(_desired_range + 1)
      0007D1 9F               [12] 3089 	subb	a,r7
      0007D2 FF               [12] 3090 	mov	r7,a
                           0007D3  3091 	C$Lab_4.c$260$1$154 ==.
                                   3092 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:260: PWMe = RANGER_CENTER + (k*Error);
      0007D3 8E*00            [24] 3093 	mov	__mulint_PARM_2,r6
      0007D5 8F*01            [24] 3094 	mov	(__mulint_PARM_2 + 1),r7
      0007D7 90 00 14         [24] 3095 	mov	dptr,#0x0014
      0007DA C0 07            [24] 3096 	push	ar7
      0007DC C0 06            [24] 3097 	push	ar6
      0007DE 12r00r00         [24] 3098 	lcall	__mulint
      0007E1 AC 82            [24] 3099 	mov	r4,dpl
      0007E3 AD 83            [24] 3100 	mov	r5,dph
      0007E5 D0 06            [24] 3101 	pop	ar6
      0007E7 D0 07            [24] 3102 	pop	ar7
      0007E9 EC               [12] 3103 	mov	a,r4
      0007EA 25*16            [12] 3104 	add	a,_RANGER_CENTER
      0007EC FC               [12] 3105 	mov	r4,a
      0007ED ED               [12] 3106 	mov	a,r5
      0007EE 35*17            [12] 3107 	addc	a,(_RANGER_CENTER + 1)
      0007F0 FD               [12] 3108 	mov	r5,a
                           0007F1  3109 	C$Lab_4.c$261$1$154 ==.
                                   3110 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:261: if(PWMe < RANGER_MIN) PWMe = RANGER_MIN;
      0007F1 C3               [12] 3111 	clr	c
      0007F2 EC               [12] 3112 	mov	a,r4
      0007F3 95*1A            [12] 3113 	subb	a,_RANGER_MIN
      0007F5 ED               [12] 3114 	mov	a,r5
      0007F6 95*1B            [12] 3115 	subb	a,(_RANGER_MIN + 1)
      0007F8 50 04            [24] 3116 	jnc	00102$
      0007FA AC*1A            [24] 3117 	mov	r4,_RANGER_MIN
      0007FC AD*1B            [24] 3118 	mov	r5,(_RANGER_MIN + 1)
      0007FE                       3119 00102$:
                           0007FE  3120 	C$Lab_4.c$262$1$154 ==.
                                   3121 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:262: if(PWMe > RANGER_MAX) PWMe = RANGER_MAX;
      0007FE C3               [12] 3122 	clr	c
      0007FF E5*18            [12] 3123 	mov	a,_RANGER_MAX
      000801 9C               [12] 3124 	subb	a,r4
      000802 E5*19            [12] 3125 	mov	a,(_RANGER_MAX + 1)
      000804 9D               [12] 3126 	subb	a,r5
      000805 50 04            [24] 3127 	jnc	00104$
      000807 AC*18            [24] 3128 	mov	r4,_RANGER_MAX
      000809 AD*19            [24] 3129 	mov	r5,(_RANGER_MAX + 1)
      00080B                       3130 00104$:
                           00080B  3131 	C$Lab_4.c$263$1$154 ==.
                                   3132 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:263: if((-5<Error) && (Error<5)) PWMe = RANGER_CENTER;
      00080B C3               [12] 3133 	clr	c
      00080C 74 FB            [12] 3134 	mov	a,#0xFB
      00080E 9E               [12] 3135 	subb	a,r6
      00080F 74 7F            [12] 3136 	mov	a,#(0xFF ^ 0x80)
      000811 8F F0            [24] 3137 	mov	b,r7
      000813 63 F0 80         [24] 3138 	xrl	b,#0x80
      000816 95 F0            [12] 3139 	subb	a,b
      000818 50 0F            [24] 3140 	jnc	00106$
      00081A C3               [12] 3141 	clr	c
      00081B EE               [12] 3142 	mov	a,r6
      00081C 94 05            [12] 3143 	subb	a,#0x05
      00081E EF               [12] 3144 	mov	a,r7
      00081F 64 80            [12] 3145 	xrl	a,#0x80
      000821 94 80            [12] 3146 	subb	a,#0x80
      000823 50 04            [24] 3147 	jnc	00106$
      000825 AC*16            [24] 3148 	mov	r4,_RANGER_CENTER
      000827 AD*17            [24] 3149 	mov	r5,(_RANGER_CENTER + 1)
      000829                       3150 00106$:
                           000829  3151 	C$Lab_4.c$266$1$154 ==.
                                   3152 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:266: return PWMe;
      000829 8C 82            [24] 3153 	mov	dpl,r4
      00082B 8D 83            [24] 3154 	mov	dph,r5
                           00082D  3155 	C$Lab_4.c$267$1$154 ==.
                           00082D  3156 	XG$motor_error$0$0 ==.
      00082D 22               [24] 3157 	ret
                                   3158 ;------------------------------------------------------------
                                   3159 ;Allocation info for local variables in function 'steering_gain'
                                   3160 ;------------------------------------------------------------
                                   3161 ;input_gain                Allocated to registers r6 
                                   3162 ;------------------------------------------------------------
                           00082E  3163 	G$steering_gain$0$0 ==.
                           00082E  3164 	C$Lab_4.c$269$1$154 ==.
                                   3165 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:269: char steering_gain(void)
                                   3166 ;	-----------------------------------------
                                   3167 ;	 function steering_gain
                                   3168 ;	-----------------------------------------
      00082E                       3169 _steering_gain:
                           00082E  3170 	C$Lab_4.c$272$1$156 ==.
                                   3171 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:272: printf("\rInput desired steering gain on keypad.\n");
      00082E 74rE8            [12] 3172 	mov	a,#___str_9
      000830 C0 E0            [24] 3173 	push	acc
      000832 74s00            [12] 3174 	mov	a,#(___str_9 >> 8)
      000834 C0 E0            [24] 3175 	push	acc
      000836 74 80            [12] 3176 	mov	a,#0x80
      000838 C0 E0            [24] 3177 	push	acc
      00083A 12r00r00         [24] 3178 	lcall	_printf
      00083D 15 81            [12] 3179 	dec	sp
      00083F 15 81            [12] 3180 	dec	sp
      000841 15 81            [12] 3181 	dec	sp
                           000843  3182 	C$Lab_4.c$273$1$156 ==.
                                   3183 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:273: printf("\rAny number below 0 will be interpreted as 1.\n");
      000843 74r11            [12] 3184 	mov	a,#___str_10
      000845 C0 E0            [24] 3185 	push	acc
      000847 74s01            [12] 3186 	mov	a,#(___str_10 >> 8)
      000849 C0 E0            [24] 3187 	push	acc
      00084B 74 80            [12] 3188 	mov	a,#0x80
      00084D C0 E0            [24] 3189 	push	acc
      00084F 12r00r00         [24] 3190 	lcall	_printf
      000852 15 81            [12] 3191 	dec	sp
      000854 15 81            [12] 3192 	dec	sp
      000856 15 81            [12] 3193 	dec	sp
                           000858  3194 	C$Lab_4.c$274$1$156 ==.
                                   3195 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:274: input_gain = kpd_input(1);
      000858 75 82 01         [24] 3196 	mov	dpl,#0x01
      00085B 12r01r99         [24] 3197 	lcall	_kpd_input
      00085E AE 82            [24] 3198 	mov	r6,dpl
      000860 AF 83            [24] 3199 	mov	r7,dph
                           000862  3200 	C$Lab_4.c$275$1$156 ==.
                                   3201 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:275: if(input_gain <= 0) input_gain = 1;
      000862 C3               [12] 3202 	clr	c
      000863 74 80            [12] 3203 	mov	a,#(0x00 ^ 0x80)
      000865 8E F0            [24] 3204 	mov	b,r6
      000867 63 F0 80         [24] 3205 	xrl	b,#0x80
      00086A 95 F0            [12] 3206 	subb	a,b
      00086C 40 02            [24] 3207 	jc	00102$
      00086E 7E 01            [12] 3208 	mov	r6,#0x01
      000870                       3209 00102$:
                           000870  3210 	C$Lab_4.c$276$1$156 ==.
                                   3211 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:276: printf("\rDesired gain is %u", input_gain);
      000870 EE               [12] 3212 	mov	a,r6
      000871 FD               [12] 3213 	mov	r5,a
      000872 33               [12] 3214 	rlc	a
      000873 95 E0            [12] 3215 	subb	a,acc
      000875 FF               [12] 3216 	mov	r7,a
      000876 C0 06            [24] 3217 	push	ar6
      000878 C0 05            [24] 3218 	push	ar5
      00087A C0 07            [24] 3219 	push	ar7
      00087C 74r40            [12] 3220 	mov	a,#___str_11
      00087E C0 E0            [24] 3221 	push	acc
      000880 74s01            [12] 3222 	mov	a,#(___str_11 >> 8)
      000882 C0 E0            [24] 3223 	push	acc
      000884 74 80            [12] 3224 	mov	a,#0x80
      000886 C0 E0            [24] 3225 	push	acc
      000888 12r00r00         [24] 3226 	lcall	_printf
      00088B E5 81            [12] 3227 	mov	a,sp
      00088D 24 FB            [12] 3228 	add	a,#0xfb
      00088F F5 81            [12] 3229 	mov	sp,a
      000891 D0 06            [24] 3230 	pop	ar6
                           000893  3231 	C$Lab_4.c$277$1$156 ==.
                                   3232 ;	C:\Users\rutmas\Documents\LITEC\LITEC\Lab 4\Lab 4 Code\Lab_4.c:277: return input_gain;
      000893 8E 82            [24] 3233 	mov	dpl,r6
                           000895  3234 	C$Lab_4.c$278$1$156 ==.
                           000895  3235 	XG$steering_gain$0$0 ==.
      000895 22               [24] 3236 	ret
                                   3237 	.area CSEG    (CODE)
                                   3238 	.area CONST   (CODE)
                           000000  3239 FLab_4$__str_0$0$0 == .
      000000                       3240 ___str_0:
      000000 0A                    3241 	.db 0x0A
      000001 54 79 70 65 20 64 69  3242 	.ascii "Type digits; end w/#"
             67 69 74 73 3B 20 65
             6E 64 20 77 2F 23
      000015 00                    3243 	.db 0x00
                           000016  3244 FLab_4$__str_1$0$0 == .
      000016                       3245 ___str_1:
      000016 20 20 20 20 20 25 63  3246 	.ascii "     %c%c%c%c%c"
             25 63 25 63 25 63 25
             63
      000025 00                    3247 	.db 0x00
                           000026  3248 FLab_4$__str_2$0$0 == .
      000026                       3249 ___str_2:
      000026 25 63                 3250 	.ascii "%c"
      000028 00                    3251 	.db 0x00
                           000029  3252 FLab_4$__str_3$0$0 == .
      000029                       3253 ___str_3:
      000029 0D                    3254 	.db 0x0D
      00002A 54 68 65 20 63 75 72  3255 	.ascii "The current direction is %u"
             72 65 6E 74 20 64 69
             72 65 63 74 69 6F 6E
             20 69 73 20 25 75
      000045 0A                    3256 	.db 0x0A
      000046 00                    3257 	.db 0x00
                           000047  3258 FLab_4$__str_4$0$0 == .
      000047                       3259 ___str_4:
      000047 0D                    3260 	.db 0x0D
      000048 54 68 65 20 72 61 6E  3261 	.ascii "The range is %u cm"
             67 65 20 69 73 20 25
             75 20 63 6D
      00005A 0A                    3262 	.db 0x0A
      00005B 00                    3263 	.db 0x00
                           00005C  3264 FLab_4$__str_5$0$0 == .
      00005C                       3265 ___str_5:
      00005C 0D                    3266 	.db 0x0D
      00005D 50 57 20 69 73 20 25  3267 	.ascii "PW is %u"
             75
      000065 0A                    3268 	.db 0x0A
      000066 00                    3269 	.db 0x00
                           000067  3270 FLab_4$__str_6$0$0 == .
      000067                       3271 ___str_6:
      000067 0D                    3272 	.db 0x0D
      000068 49 6E 70 75 74 20 64  3273 	.ascii "Input desired heading on keypad, in degrees."
             65 73 69 72 65 64 20
             68 65 61 64 69 6E 67
             20 6F 6E 20 6B 65 79
             70 61 64 2C 20 69 6E
             20 64 65 67 72 65 65
             73 2E
      000094 0A                    3274 	.db 0x0A
      000095 00                    3275 	.db 0x00
                           000096  3276 FLab_4$__str_7$0$0 == .
      000096                       3277 ___str_7:
      000096 0D                    3278 	.db 0x0D
      000097 41 6E 79 20 6E 75 6D  3279 	.ascii "Any number above 360 will be interpreted as 360."
             62 65 72 20 61 62 6F
             76 65 20 33 36 30 20
             77 69 6C 6C 20 62 65
             20 69 6E 74 65 72 70
             72 65 74 65 64 20 61
             73 20 33 36 30 2E
      0000C7 0A                    3280 	.db 0x0A
      0000C8 00                    3281 	.db 0x00
                           0000C9  3282 FLab_4$__str_8$0$0 == .
      0000C9                       3283 ___str_8:
      0000C9 0D                    3284 	.db 0x0D
      0000CA 44 65 73 69 72 65 64  3285 	.ascii "Desired heading is %u degrees"
             20 68 65 61 64 69 6E
             67 20 69 73 20 25 75
             20 64 65 67 72 65 65
             73
      0000E7 00                    3286 	.db 0x00
                           0000E8  3287 FLab_4$__str_9$0$0 == .
      0000E8                       3288 ___str_9:
      0000E8 0D                    3289 	.db 0x0D
      0000E9 49 6E 70 75 74 20 64  3290 	.ascii "Input desired steering gain on keypad."
             65 73 69 72 65 64 20
             73 74 65 65 72 69 6E
             67 20 67 61 69 6E 20
             6F 6E 20 6B 65 79 70
             61 64 2E
      00010F 0A                    3291 	.db 0x0A
      000110 00                    3292 	.db 0x00
                           000111  3293 FLab_4$__str_10$0$0 == .
      000111                       3294 ___str_10:
      000111 0D                    3295 	.db 0x0D
      000112 41 6E 79 20 6E 75 6D  3296 	.ascii "Any number below 0 will be interpreted as 1."
             62 65 72 20 62 65 6C
             6F 77 20 30 20 77 69
             6C 6C 20 62 65 20 69
             6E 74 65 72 70 72 65
             74 65 64 20 61 73 20
             31 2E
      00013E 0A                    3297 	.db 0x0A
      00013F 00                    3298 	.db 0x00
                           000140  3299 FLab_4$__str_11$0$0 == .
      000140                       3300 ___str_11:
      000140 0D                    3301 	.db 0x0D
      000141 44 65 73 69 72 65 64  3302 	.ascii "Desired gain is %u"
             20 67 61 69 6E 20 69
             73 20 25 75
      000153 00                    3303 	.db 0x00
                                   3304 	.area XINIT   (CODE)
                                   3305 	.area CABS    (ABS,CODE)
